a
b
e
f
a
x
xxx

<script>

/*

This omni stringifier works in a multi step way

Reads: This is handled in a single step way, mostly like JSON.stringify, only difference being, it also handles functions, symbols and custom objects
Writes: 
This has two steps 
step 1: You don't actually stringify the object, you replace every reference inside the object with an object id, and return a new object 
example: {1:d} => {1:{__dynId: 2}}, a = > {__dynId: 4};

step 2: You iterate through the object, and convert every id into the actual path, or if no id is there, you simply stringify it like before

*/


(function() {
  var scope,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  scope = this;

  var objectToId = new WeakMap();
  var idToObject = new Map();


  var tracer; 
  var objectUID = 1;

function createXPathFromElement(elm) { 
    // var allNodes = document.getElementsByTagName('*'); 
    for (var segs = []; elm && (elm.nodeType == 1 || elm.nodeType == 3); elm = elm.parentNode) 
    { 
        /*if (elm.hasAttribute && elm.hasAttribute('id')) { 
                var uniqueIdCount = 0; 
                for (var n=0;n < allNodes.length;n++) { 
                    if (allNodes[n].hasAttribute('id') && allNodes[n].id == elm.id) uniqueIdCount++; 
                    if (uniqueIdCount > 1) break; 
                }; 
                if ( uniqueIdCount == 1) { 
                    segs.unshift('id("' + elm.getAttribute('id') + '")'); 
                    return segs.join('/'); 
                } else { 
                    segs.unshift(elm.localName.toLowerCase() + '[@id="' + elm.getAttribute('id') + '"]'); 
                } 
        } else if (elm.hasAttribute && elm.hasAttribute('class')) { 
            segs.unshift(elm.localName.toLowerCase() + '[@class="' + elm.getAttribute('class') + '"]'); 
        } else { */
          if (elm.localName) {
            for (i = 1, sib = elm.previousSibling; sib; sib = sib.previousSibling) { 
                if (sib.localName == elm.localName)  i++; }; 
                segs.unshift(elm.localName.toLowerCase() + '[' + i + ']'); 
          } else {
            for (i = 1, sib = elm.previousSibling; sib; sib = sib.previousSibling) { 
                if (sib.nodeType == 3)  i++; }; 
                segs.unshift("text()" + '[' + i + ']'); 
          }
        // }; 
    }; 
    return segs.length ? '/' + segs.join('/') : null; 
}; 

function lookupElementByXPath(path) { 
    var evaluator = new XPathEvaluator(); 
    var result = evaluator.evaluate(path, document.documentElement, null,XPathResult.FIRST_ORDERED_NODE_TYPE, null); 
    return  result.singleNodeValue; 
} 


  function stringify(obj) {
        try {
            return JSON.stringify(obj, function (key, value) {
              if (value && value.__isProxy)
                    value = value.__target;
              var fnBody;
              if (value instanceof Function || typeof value == 'function') {

                if ((/\{\s*\[native code\]\s*\}/).test(value.toString())) {
                    return value.name;
                }
                fnBody = value.toString();

                if (fnBody.length < 8 || fnBody.substring(0, 8) !== 'function') { /*this is ES6 Arrow Function*/
                  return '_NuFrRa_' + fnBody;
                }
                return fnBody;
              }
              if (value instanceof RegExp) {
                return '_PxEgEr_' + value;
              }
              return value;
            });
        } catch(e){
            return e;
        }
    };

  (function(definition) {
      return scope.Omni = definition();
  })(function() {
    var ContextResolver, Omni, MultiResolver, Resolver, Util;
    Util = {
      d2h: function(d) {
        return d.toString(16);
      },
      h2d: function(h) {
        return window.__tracerParseInt(h, 16);
      },
      supportsProto: {}.__proto__ != null,
      supportsFunctionNames: typeof (function() {}).name === "string"
    };
    Util.functionName = Util.supportsFunctionNames ? function(func) {
        if (func)
            return func.name;
        else return func
    } : function(func) {
      var _ref;
      return (_ref = func.toString().match(/function ([^(]*)/)) != null ? _ref[1] : void 0;
    };
    Util.isArray = Array.isArray ? Array.isArray : function(arr) {
      return Object.prototype.toString.call(arr) === "[object Array]";
    };
    Omni = (function() {

      Omni.name = 'Omni';

      Omni.NonPrototypeFunctionError = (function(_super) {

        __extends(NonPrototypeFunctionError, _super);

        NonPrototypeFunctionError.name = 'NonPrototypeFunctionError';

        function NonPrototypeFunctionError(object, name) {
          this.object = object;
          this.name = name;
          this.message = "[OMNI] Couldn't serialize object; had non-prototype function '" + this.name + "'";
        }

        return NonPrototypeFunctionError;

      })(Error);

      Omni.PrototypeNotFoundError = (function(_super) {

        __extends(PrototypeNotFoundError, _super);

        PrototypeNotFoundError.name = 'PrototypeNotFoundError';

        function PrototypeNotFoundError(object, cons_id) {
          this.object = object;
          this.cons_id = cons_id;
          this.message = "[OMNI] Prototype not found for object; looked for " + this.cons_id;
        }

        return PrototypeNotFoundError;

      })(Error);

      Omni.AnonymousConstructorError = (function(_super) {

        __extends(AnonymousConstructorError, _super);

        AnonymousConstructorError.name = 'AnonymousConstructorError';

        function AnonymousConstructorError(object) {
          this.object = object;
          this.message = "[OMNI]Couldn't resolve constructor name; seems it has an anonymous constructor and object's prototype has no #constructor_name property to provide hints";
        }

        return AnonymousConstructorError;

      })(Error);

      Omni.VersionInstancePropertyError = (function(_super) {

        __extends(VersionInstancePropertyError, _super);

        VersionInstancePropertyError.name = 'VersionInstancePropertyError';

        function VersionInstancePropertyError(object) {
          this.object = object;
          this.message = "[OMNI]Objects can't have versions on the instances; can only be on the prototype";
        }

        return VersionInstancePropertyError;

      })(Error);

      Omni.DOMConstructorError = (function(_super) {

        __extends(DOMConstructorError, _super);

        DOMConstructorError.name = 'DOMConstructorError';

        function DOMConstructorError(object) {
          this.object = object;
          this.message = "[OMNI] can't serialize dom|cssom objects";
        }

        return DOMConstructorError;

      })(Error);

      Omni.DOMXMLPathError = (function(_super) {
        __extends(DOMXMLPathError,_super);

        DOMXMLPathError.name = 'DOMXMLPathError';
        function DOMXMLPathError(object){
          this.object = object;
          this.message = "[OMNI] can't find dom using xml path";
        }
        return DOMXMLPathError;
      })(Error)

      function Omni(resolver) {
        this.resolver = resolver != null ? resolver : null;
        if (!(this.resolver != null)) {
          if (typeof window === "undefined") {
            throw new Error("[OMNI] A context-resolver is required in non-browser environments");
          }
          this.resolver = new ContextResolver(scope);
        }
        this.errorHandler = function(e) {
          throw e;
        };
        this.migrations = {};
      }

      var isDOMInheritedProperty = function(method){
        return method && (method instanceof EventTarget || method instanceof HTMLCollection || method instanceof NodeList || method.readState
            /*|| method.click || method.appendData*/) /*&& (method && method.self != method)*/
      }


      Omni.prototype.assignId = function(obj){
        if (!obj) return;
        var _id = objectToId.get(obj);
        if (!_id) {
            // Object.defineProperty(obj, "__Omni_id", {
            //     value : Util.d2h(this.counter++),
            //     writable: false,
            //     configurable: false, 
            //     enumerable: false
            // })
            _id = Util.d2h(this.counter++);
            objectToId.set(obj, _id);
        }
        return _id;
      }

      var handleProxyObjs = function(obj){
        var objId = __tracer.getIdFromProxy(obj);
        if (objId == null) return;
        var nodeId = obj.__debug || __tracer.getShadowStackHead();
        if (!nodeId) return;
        var writeLog = __tracer.getInvocationToWrites();
        if (!writeLog[nodeId])
          writeLog[nodeId] = [];
        var isBrokenReference;
        if (writeLog[nodeId]){
          writeLog[nodeId].forEach((entry)=>{
            if (entry[0] == "broken-reference" && entry[1]== objId)
              isBrokenReference = true;
          })
        }
        if (isBrokenReference)
          return null;
        writeLog[nodeId].push([obj.__isProxy, objId]);
        return {__dynId:objId, state: obj.__isProxy, nodeId: obj.__debug};
      }

      var handleProxyIds = function(id,state,nodeId){
        var path = __tracer.getPathFromProxyId(id,state,nodeId);
        if (path)
           return {__dynPath: path};
      }

      Omni.prototype.counter = 0;

      var OMNI_SIZE_LIMIT=10000;
      Omni.prototype.size = 0;

      var customStringify = function(input){
        var ignoreLSKeys = ["fnCacheExists","keyMap","signature"]
        return JSON.stringify(input, function(key, value){
            if (ignoreLSKeys.indexOf(key)<0)
              return value;
        })
      }

      function isNative(fn) {
        return (/\{\s*\[native code\]\s*\}/).test('' + fn);
      }

      function exposeClosureScope(input, closureStringifier, seen_objs){
        var clObj = input.__getScope__ && input.__getScope__();
        if (!clObj){
          //If global function, then alright to not have scope exposed since it
          // is not a closure function. Otherwise, error 
          if (input.name && window[input.name] == input)
            return "";
          else throw new Error("Closure scope could not be exposed"); 
        }
        var closureStr = {};
        Object.keys(clObj).forEach((k)=>{
          if (k.indexOf("set")>=0 || k == "__isClosureObj"
            || input == clObj[k]) return;
          closureStr[k] = clObj[k];
          // closureStr += " var " + k + " = " + stringifier(clObj[k],"read",2) + ";";
        })
        return closureStringifier.stringify(closureStr,"write",2, seen_objs);
      }

      /*
        Returns a an array where the first index is the stringified value is non primitive
        otherwise the value itself. The second indicates whether the input was a primitive data
        type
      */
      Omni.prototype.stringify = function(input,state,stage, seen_objs) {
        try {

          var arr, i, result, output,_id;

          var seen_objs;
          if (!seen_objs)
            seen_objs = new Set();
          else seen_objs = seen_objs;
          this.size = 0;
          this.processed_inputs = [];
          var strDelim = ";;&;;";
          var emptyFn = function(a){return a};
          var stringify = state == "read" || stage == 2 ? function(o,skipMD){
            var str = JSON.stringify(o);
            if (state != "read" || skipMD)
              return str;
            var finalStr;
            if (o && Array.isArray(o)){
              finalStr = str + strDelim + "array" + strDelim + Object.keys(o).length + strDelim + o.__proto__.constructor.name;
            } else if( o && typeof o == "object")
              finalStr = str + strDelim + typeof o + strDelim + Object.keys(o).length + strDelim + o.__proto__.constructor.name;
            else if (o) finalStr = str + strDelim + typeof o + strDelim + o.__proto__.constructor.name;
            else finalStr = str;
            return finalStr;
          }: emptyFn; 
          var primStringify = state == "read" || stage == 2 ? function (a){
            return [a + strDelim + typeof a,true];
          } : function (a){
            return a;
          };
          var _encodeURI = state == "read" || stage == 2 ? encodeURI : emptyFn; 

          if (state == "write" && stage == 1 && input && input.__isProxy){
            var _ret = handleProxyObjs(input);
            if (_ret) return stringify(_ret);
          } else if (state == "write" && stage == 2 && input && input.__dynId){
            var _ret = handleProxyIds(input.__dynId, input.state, input.nodeId);
            if (_ret) return stringify(_ret);
          }

          if (input && input.__isProxy)
              input = input.__target;

          if (input && input instanceof Storage)
            return customStringify(input);

          result = (function() {
            var _i, _len;
            switch (typeof input) {
              case "number":
              case "boolean":
                return primStringify(input);
              case "string":
                return primStringify((input));
              case "symbol":
                if (state == "write") 
                  throw new Error("[OMNI] can't serialize symbols");
                else return "";
                break;
              case "function":
                // if (state == "write") 
                //   throw new Error("[OMNI] can't serialize functions");
                if (state == "read") return "__func__source";
              default:
                if (state == "write")
                  _id = this.assignId(input);
                if (isDOMInheritedProperty(input)){
                  __tracer.updateDC();
                  var dom2json = {};
                  dom2json.xpath = createXPathFromElement(input);
                  /*Not an accurate check since some documents objects don't
                   satisfy this condition, hence commenting*/
                  if (input.__proto__.constructor.name == "HTMLDocument") {
                    // dom2json = domJSON.toJSON(input,{
                    //   deep: false,
                    //   attributes : ['id'],
                    //   domProperties: false,
                    // });
                    if (state == "write") 
                      dom2json.document = true;
                  }
                  if (state == "write") {
                    dom2json.__Omni_id = _id;
                    dom2json.__Omni_type = "DOM";
                  }
                
                  return stringify(dom2json,true);
                }
                // try {
                //   var __s =  JSON.stringify(input);
                // } catch (e){
                //   if (e.name == "TypeError")
                //     throw new Error("circular Object error");
                // }
                if (Util.isArray(input)) {
                  seen_objs.add(input);
                  arr = [];
                  for (_i = 0, _len = input.length; _i < _len; _i++) {
                    i = input[_i];
                    arr.push(this.analyze(i,state,seen_objs,stage));
                  }
                  // if (state == "write") 
                    // arr.push({__Omni_id:_id});
                  // arr.__Omni_id = input.__Omni_id;
                  return stringify(arr);
                } else {
                  // seen_objs.add(input);
                  output = this.analyze(input,state,seen_objs,stage);
                  if (output == null)
                    return primStringify(output);
                  return stringify(output);
                }
            }
          }).call(this);
          return result;
        } catch (e){
            return e;
        }
      };

      Omni.prototype.cleanAfterStringify = function() {
        var input, _i, _len, _ref;
        _ref = this.processed_inputs;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          if (input) {
            delete input.__Omni_id;
          } 
          // if (Util.isArray(input)){
          //   input.pop();
          // }
        }
        return true;
      };

      Omni.prototype.analyze = function(input,state,seen_objs,stage) {
        if (this.size>OMNI_SIZE_LIMIT){
          throw new Error("[OMNI] Object size exceeded omni limit");
        }
        if (state == "write" && stage == 1 && input && input.__isProxy){
            var _ret = handleProxyObjs(input);
            if (_ret) return _ret;
          } else if (state == "write" && stage == 2 && input && input.__dynId != null){
            var _ret = handleProxyIds(input.__dynId,input.state, input.nodeId);
            if (_ret) return _ret;
        }
        if (input && input.__isProxy)
              input = input.__target;
        var cons, i, k, output, v, _i, _len,_id;
        switch (typeof input) {
          case "number":
             this.size += 8;
            return input;
          case "string":
            this.size+=input.length*2;
            return input
          case "boolean":
            this.size += 4;
            return input;
          case "symbol":
            if (state == "write") 
              return this.errorHandler(new Error("[OMNI] can't serialize symbols"));
            else return "";
          case "undefined":
            return void 0;
          case "function":
            // if (state == "write") 
            //   return this.errorHandler(new Error("[OMNI] can't serialize functions"));
            if (state == "read") return "__func__source";
          default:
            if (input === null) {
              return null;
            } else {
              if (isDOMInheritedProperty(input)){
                  if (state == "write") 
                    _id = this.assignId(input);
                  __tracer.updateDC();
                  var dom2json = {};
                  dom2json.xpath = createXPathFromElement(input);
                  if (input.__proto__.constructor.name == "HTMLDocument") {
                    // dom2json = domJSON.toJSON(input,{
                    //   deep: false,
                    //   attributes : ['id'],
                    //   domProperties: false,
                    // });
                    if (state == "write")
                      dom2json.document = true;
                  } 
                  if (state == "write") {
                    dom2json.__Omni_id = _id;
                    dom2json.__Omni_type = "DOM";
                  }
                
                  return (dom2json);
              } else if (Util.isArray(input)) {
              if (seen_objs.has(input))
                throw new Error("circular Object error");
              seen_objs.add(input);
              if (state == "write")
                _id = this.assignId(input);
              output = [];
              for (i = _i = 0, _len = input.length; _i < _len; i = ++_i) {
                v = input[i];
                output[i] = this.analyze(v,state,seen_objs,stage);
              }
              seen_objs.delete(input);
              // if (state == "write") 
                // output.push({__Omni_id : _id});
              // output.__Omni_id == input.__Omni_id;
              return output;
            } else { 
                    if (seen_objs.has(input))
                      throw new Error("circular object error");
                    seen_objs.add(input);
                    if (state == "write")
                      _id = this.assignId(input);
                    // input.__Omni_id = _id;
                    // this.processed_inputs.push(input);
                    output = new Object;
                    for (k in input) {
                      v = input[k];
                      if (Object.hasOwnProperty.call(input, k) && k != "__getScope__") {
                        output[k] = this.analyze(v,state,seen_objs,stage);
                      }
                    }
                    seen_objs.delete(input);
                    // if (state == "write") 
                      // output.__Omni_id = _id;
                    cons = Util.functionName(input.constructor);
                    if (cons === "" && !Object.hasOwnProperty.call(input, "constructor_name")) {
                      cons = input.constructor_name;
                    }
                    if (!(cons != null)) {
                      this.errorHandler(new Omni.AnonymousConstructorError(input));
                    }
                    if (cons != null && ( cons.indexOf("CSS")>=0 || cons.indexOf("HTML")>=0))
                        this.errorHandler(new Omni.DOMConstructorError(input))
                    if (cons !== "Object") {
                      if (state == "write") {
                        output.__Omni_cons = cons;
                        if (cons == "Function") {
                          /*If serializing function, store the function body*/
                          if (isNative(input))
                            return this.errorHandler(new Error("[OMNI] can't serialize native functions"));
                          output.__body__ = input.toString()
                          output.__scope__ = exposeClosureScope(input, this, seen_objs);
                          if (output.__scope__ && output.__scope__.stack)
                            throw new Error("Closure scope could not be exposed");
                        }
                      } else {
                        switch (cons){
                          case "Map": output =  Array.from(input.entries()); break;
                          case "Set": output =  Array.from(input.values()); break;
                          case "RegExp": output =  input.source; break;
                        }
                      }
                    }
                    // if (input.hasOwnProperty("version")) {
                    //   this.errorHandler(new Omni.VersionInstancePropertyError(input));
                    // }
                    // if (input.version != null) {
                    //   output.version = input.version;
                    // }
                    return output;
                }
            }
        }
      };

      Omni.prototype.setErrorHandler = function(errorHandler) {
        this.errorHandler = errorHandler;
      };

      Omni._refMatcher = /__Omni_ref_(.*)/;

      Omni.prototype.parse = function(input, params) {
        try {
          var l, o,_o, obj, obj_key, ref_id, reference, _i, _len, _ref;
          this.identified_objects = [];
          this.references_to_resolve = [];
          try {
           _o = JSON.parse(input);
         } catch (e){
            return input;
         }
          o = this.fixTree(_o,params);
          if (Util.isArray(o) || ((o != null) && typeof o === "object") && !_o.__Omni_type) {
            l = o.length;
            if (o != null) {
              _ref = this.references_to_resolve;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                reference = _ref[_i];
                obj = reference[0], obj_key = reference[1], ref_id = reference[2];
                // obj[obj_key] = this.identified_objects[ref_id];
                obj[obj_key] = idToObject.get(ref_id);
              }
              // this.clean(o);
            }
          }
          return o;
        } catch (e){
          throw e;
        }
      };

      Omni.prototype.fixTree = function(obj,params) {
        var k, k2, m, proto, t, tmp, v, v2, _i, _len;
        if (obj && obj.__Omni_id) {
            var corObj = idToObject.get(Util.h2d(obj.__Omni_id));
            if (corObj)
                return corObj;
        }

        if (params && obj && obj.__dynPath){
          var obj = __tracer.traversePath(obj.__dynPath,params);
          return obj;
        }

        if (obj && obj.__Omni_type == "DOM"){
          if (obj.document)
            return document;
          // var o = domJSON.toDOM(obj);
          var o = lookupElementByXPath(obj.xpath);
          if (!o){
            this.errorHandler(new Omni.DOMXMLPathError(obj));
          }
          // idToObject.set(Util.h2d(obj.__Omni_id), o);
          return o;
        }

        if (Util.isArray(obj)) {
            // if (obj[obj.length - 1].__Omni_id){
            //     var _id = obj[obj.length - 1].__Omni_id;
            //     var corObj = idToObject.get(Util.h2d(_id));
            //     if (corObj)
            //         return corObj;
            //     else {
            //         idToObject.set(Util.h2d(_id), obj);
            //     }
            //     obj.pop();
            // }
          for (k = _i = 0, _len = obj.length; _i < _len; k = ++_i) {
            v = obj[k];
            v = this.fixTree(v,params);
            if (v === "__Omni_undef") {
              obj[k] = void 0;
            /*} else if (typeof v === "string" && (m = v.match(Omni._refMatcher))) {
              k2 = Util.h2d(m[1]);
              this.references_to_resolve.push([obj, k, k2]);
            } else if ( (k == _len -1) && v.__Omni_id) {
                idToObject.set(Util.h2d(v.__Omni_id), obj);
            */} else {
              obj[k] = v;
            }
          }
        } else if (obj === "__Omni_undef") {
          obj = void 0;
        } else if ((obj != null) && typeof obj === "object") {
          __id = obj.__Omni_id;
          if (obj && (obj.__Omni_cons != null)) {
            proto = this.resolvePrototype(obj.__Omni_cons);
            if (proto != null) {
              if (Util.supportsProto) {
                if (obj.__Omni_cons != "Function")
                  t = new proto;
                else {
                  var body = obj.__body__;
                  var scopeObj = __tracer.omni.parse(obj.__scope__);
                  with (scopeObj){
                    // t = new Function(' return ' + body)()
                    eval("t=" + body);
                  }
                }
                for (k in obj) {
                  v = obj[k];
                  if (obj.hasOwnProperty(k) && k != "__Omni_cons" && k != "__body__" 
                    && k != "__scope__") {
                    t[k] = v;
                  }
                }
                // idToObject.set(Util.h2d(obj.__Omni_id), t);
                obj = t;
              }
            } else {
              this.errorHandler(new Omni.PrototypeNotFoundError(obj, obj.__Omni_cons));
            }
          }
          for (k in obj) {
            v = obj[k];
            if (obj.hasOwnProperty(k)) {
              v = this.fixTree(v,params);
              if (k === "__Omni_id") {
                v2 = Util.h2d(v);
                // this.identified_objects[v2] = obj;
                // idToObject.set(v2, obj);
              } else if (v === "__Omni_undef") {
                obj[k] = void 0;
              } else if (typeof v === "string" && (m = v.match(Omni._refMatcher))) {
                k2 = Util.h2d(m[1]);
                this.references_to_resolve.push([obj, k, k2]);
              } else {
                obj[k] = v;
              }
            }
          }
        // idToObject.set(Util.h2d(__id), obj);
        } else if (typeof obj == "string")
            return (obj);
        return obj;
      };

      Omni.prototype.resolvePrototype = function(cons_id) {
        if (!(this.resolver != null)) {
          throw new Error("No Omni resolver found -- you should specify one in the Omni constructor!");
        }
        return this.resolver.resolve(cons_id);
      };

      Omni.prototype.clean = function(o, cleaned) {
        var i, k, migrations, num, v, _i, _j, _len, _ref, _ref1;
        // if (cleaned == null) {
        //   cleaned = [];
        // }
        if (o === null || typeof o !== "object") {
          return true;
        }
        // if (!Util.isArray(o) && cleaned.indexOf(o) > -1) {
        //   return true;
        // }
        /*migrations = this.migrations[o.__Omni_cons];
        if ((o.version != null) && (migrations != null) && o.version < migrations.length) {
          for (num = _i = _ref = o.version, _ref1 = migrations.length - 1; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; num = _ref <= _ref1 ? ++_i : --_i) {
            migrations[num].call(o);
          }
          // delete o.version;
        }*/

        if (o && o.__Omni_type){
          delete o.__Omni_type;
          return;
        }

        // cleaned.push(o);
        if (Util.isArray(o)) {
          // if (o.find(el=>el.__Omni_id))
          //   o.pop();
          for (_j = 0, _len = o.length; _j < _len; _j++) {
            i = o[_j];
            this.clean(i);
          }
        } else {
          for (k of Object.getOwnPropertyNames(o)) {
            v = o[k];
            if (k === "__Omni_id" || k === "__Omni_cons" || k == "__body__") {
              delete o[k];
            } else {
              this.clean(v);
            }
          }
        }
        return true;
      };

      Omni.prototype.migration = function(klass, index, callback) {
        var all_versions;
        switch (typeof klass) {
          case "function":
            klass = klass.name;
            if (klass === "") {
              this.errorHandler(new Omni.AnonymousConstructorError(klass));
            }
            break;
          case "string":
            null;

            break;
          default:
            throw new Error("invalid class passed in; pass a function or a string");
        }
        all_versions = this.migrations[klass];
        if (!(all_versions != null)) {
          all_versions = this.migrations[klass] = [];
        }
        all_versions[index - 1] = callback;
        return true;
      };

      return Omni;

    })();
    Resolver = (function() {

      Resolver.name = 'Resolver';

      function Resolver() {}

      Resolver.prototype.resolve = function(cons_id) {
        throw new Error("abstract");
      };

      return Resolver;

    })();
    ContextResolver = (function(_super) {

      __extends(ContextResolver, _super);

      ContextResolver.name = 'ContextResolver';

      function ContextResolver(context) {
        this.context = context;
      }

      ContextResolver.prototype.resolve = function(cons_id) {
        var v;
        v = this.context[cons_id];
        if (v != null) {
          return v;
        } else {
          return null;
        }
      };

      return ContextResolver;

    })(Resolver);
    MultiResolver = (function(_super) {

      __extends(MultiResolver, _super);

      MultiResolver.name = 'MultiResolver';

      function MultiResolver(resolvers) {
        this.resolvers = resolvers != null ? resolvers : [];
      }

      MultiResolver.prototype.resolve = function(cons_id) {
        var proto, res, _i, _len, _ref;
        _ref = this.resolvers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          res = _ref[_i];
          proto = res.resolve(cons_id);
          if (proto != null) {
            return proto;
          }
        }
        return null;
      };

      return MultiResolver;

    })(Resolver);
    Omni.Util = Util;
    Omni.Resolver = Resolver;
    Omni.ContextResolver = ContextResolver;
    Omni.MultiResolver = MultiResolver;
    return Omni;
  });

}).call(this);
/*
 * Copyright (c) 2012 Massachusetts Institute of Technology, Adobe Systems
 * Incorporated, and other contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/*
The source of source-map is included below on the line beginning with "var sourceMap",
and its license is as follows:

Copyright (c) 2009-2011, Mozilla Foundation and contributors
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the names of the Mozilla Foundation nor the names of project
  contributors may be used to endorse or promote products derived from this
  software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED T, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
Keywords to manage code base better

TODO - code sections need to be reimplemented or handled better
SUPPRESS - caught exceptions which our suppressed - need to be handled better
LOG - log statements which are used to debug

TODO

    - Fine tracking of arguments
        - Instead of stringifying the entire argument object, only track object level changes (read, write) to the individual object
    - Signature Propagation
        - While trying to build the call graph, some nodes are not found: Is it because I am deleting nodes while stringifying?
*/

if (typeof window != "undefined"){
    if (typeof window.top.setupStateTime == "undefined") {
        window.top.setupStateTime = {};
        window.top.setupStateCounter=0;
    }
}

if (typeof window.__tracer === 'undefined') {
__tracer = new __declTracerObject__(window);
function __declTracerObject__(window) {
    var setupStateStartTime = performance.now();
    var e2eTesting = false;
    var trackOnlyLeaf = false;
    var functions = new Set();
    var invocations = {};
    var customLocalStorage = {}; /* Use this in place of the localstorage API for faster access. */
    var counter = 0;
    var shadowStack = [];
    var _shadowStackHead;
    var processedSignature = {};
    var callGraph = {};
    var parentNodes = [];
    var nonLeafNodes = [];
    var functionsSeen = [];
    var pageRecorded = false;
    var simpleReplay = true;
    var cacheStats = {hits: [], misses: {error:[], empty:[], mismatch:[]}};
    var functionStats = {noarg:[], prim: [], prim_objects:[], function: []};
    var nonCacheableNodes = {};
    var invocationsIndName = {};
    var invocationsIndState = {};
    var invocationToArgProxy = {};
    var invocationToThisProxy = {}
    var invocationToClosureProxy = {};
    var keysToStdKeys = {};
    var cacheableSignature = {};
    var pageLoaded = true;;
    var oldPageLoaded = [];
    var INVOCATION_LIMIT = 5000000;;
    var domCounter =0;
    var invocationToWrites = {};
    var ND = [];
    var curRoot = null;
    var functionToScopes = {};
    var omniStringifier = Omni ? new Omni() : "";
    // var parse = omniStringifier.parse;
    var rootInvocs = [];
    var sigSizeLimit = 500; // Number of reads and writes allowed per invocations
    var OMNI_SIZE_LIMIT=10000; //Length of string allowed to be read or written
    var instrumentationPattern = "cg";
    var invocationList = [];
    var timingInfo = {};
    var sigSizes = {};
    var PMD = {};
    var runtimeInfo = {runtimeInfo};
    var runTimePurged = 0;
    var writeStateProcessed = new Map();

    /*
    For efficient recording, constraint the size of certain objects
    - signature length should be less than 50 entries
    - during stringification the object length should be less than certain bytes*TODO
    */

    window.objStrCount = {
        argument_reads:0,
        argument_writes:0,
        closure_reads:0,
        closure_writes:0,
        global_writes:0,
        global_reads:0,
        this_reads:0,
        this_writes:0
    };

    //Define all your custom methods, before they are overwritten
    //by user javascript
    // Declare all the custom prototype methods here
    var customMethods = {getOwnPropertyDescriptor: Object.getOwnPropertyDescriptor, getOwnProperyNames: Object.getOwnProperyNames, ownKeys: Reflect.ownKeys}

    //temporary hack to store non stringifiable functions
    // var nodesByProperties = {
    //     "NOGSNOARG":[], "GS_f":[], "GS":[],
    //     "Function":{}, "RTI":{RTI},
    //     "antiLocal":{antiLocal},"ND":{ND}, "DOM":{DOM}
    // };

    var eraseCookies = function () {
        var cookies = document.cookie.split("; ");
        for (var c = 0; c < cookies.length; c++) {
            var d = window.location.hostname.split(".");
            while (d.length > 0) {
                var cookieBase = encodeURIComponent(cookies[c].split(";")[0].split("=")[0]) + '=; expires=Thu, 01-Jan-1970 00:00:01 GMT; domain=' + d.join('.') + ' ;path=';
                var p = location.pathname.split('/');
                document.cookie = cookieBase + '/';
                while (p.length > 0) {
                    document.cookie = cookieBase + p.join('/');
                    p.pop();
                };
                d.shift();
            }
        }
    }

    var fnCacheExists = false;
    try {
        if (fnCacheExists = localStorage.getItem("fnCacheExists")){
            console.log("Fn cache exists, skippping function executions..");
            keysToStdKeys = JSON.parse(localStorage.getItem("keyMap"));

            var _processedSignature = JSON.parse(localStorage.getItem("signature"));
            Object.keys(_processedSignature).forEach((key)=>{
                processedSignature[key] = JSON.parse(_processedSignature[key], true);
            })
            console.log("Function signatures loaded..");
            pageLoaded = true;

            //Restore cookies
            eraseCookies();
            var prevCookie = localStorage.getItem("cookieVal");
            document.cookie = prevCookie;
        } else {
            localStorage.setItem("cookieVal",document.cookie);
        }
    } catch (e){
        console.error("error while reading local storage " + e);
    }

    window.addEventListener("load", function(){
        if (!pageRecorded) {
            console.log("PROXY STATS");
            console.log(window.proxyReadCount, window.proxyWriteCount);
            /*Delete performance shims since we need all the entries now
            However only do this when the top level page fires
            Some iframe with a sep*/
            // delete window.performance.getEntries
            // delete window.performance.getEntriesByType
        } else {
            console.log("Page successfully replayed");
        }
        // if (window.top == window)
        //     debugger;
        // if (instrumentationPattern == "replay")
        //     debugger;

    })

    var processFinalSignature = function(){
        // First process the global state of every function
        var proxyPrivates = globalProxyHandler.accessToPrivates();
        // Process the signature to construct meaningful paths
        var sigProcessor = new SignatureProcessor(customLocalStorage, proxyPrivates.ObjectTree, callGraph, "global");
        sigProcessor.process();
        // sigProcessor.postProcess();
        // sigProcessor.signaturePropogate();
        processedSignature = sigProcessor.processedSig;

        Object.keys(customLocalStorage).forEach((invocationId)=>{
            var invocationSignature = {};
            invocationSignature[invocationId] = processedSignature[invocationId];
            if (!invocationSignature[invocationId]) return;
            //For each invocation get all the scopes it touches
            functionToScopes[invocationId] && functionToScopes[invocationId].forEach((i_scope)=>{
                var closureProxyHandler = invocationToClosureProxy[i_scope];
                var proxyPrivates = closureProxyHandler.accessToPrivates();
                var sigProcessor = new SignatureProcessor(invocationSignature, proxyPrivates.ObjectTree, callGraph, `closure_${i_scope}`);
                sigProcessor.process();
                // sigProcessor.postProcess();
                processedSignature[invocationId] = sigProcessor.processedSig[invocationId];
            })
        })

        //Now individual iterate the invocations and convert object ids to strings
        // Object.keys(invocationToArgProxy).forEach((invocationId)=>{
        //      // Return if not leaf node
        //     if (trackOnlyLeaf &&  callGraph[invocationId].length) {
        //         nonCacheableNodes[invocationId] = "non-leaf";
        //         return;
        //     }
        //     if (invocationId in nonCacheableNodes) return;
        //     var argProxyHandler = invocationToArgProxy[invocationId];
        //     var proxyPrivates = argProxyHandler.accessToPrivates();
        //     var invocationSignature = {};
        //     invocationSignature[invocationId] = processedSignature[invocationId];
        //     if (!invocationSignature[invocationId]) return;
        //     var sigProcessor = new SignatureProcessor(invocationSignature, proxyPrivates.ObjectTree, callGraph, "argument");
        //     sigProcessor.process();
        //     // sigProcessor.postProcess();
        //     processedSignature[invocationId] = sigProcessor.processedSig[invocationId];
        // })

        // Object.keys(invocationToThisProxy).forEach((invocationId)=>{
        //     // Return if not leaf node
        //     if (trackOnlyLeaf && callGraph[invocationId].length) return;
        //     if (invocationId in nonCacheableNodes) return;
        //     var thisProxyHandler = invocationToThisProxy[invocationId];
        //     var proxyPrivates = thisProxyHandler.accessToPrivates();
        //     var invocationSignature = {};
        //     invocationSignature[invocationId] = processedSignature[invocationId];
        //     if (!invocationSignature[invocationId]) return;
        //     var sigProcessor = new SignatureProcessor(invocationSignature, proxyPrivates.ObjectTree, callGraph, "this");
        //     sigProcessor.process();
        //     // sigProcessor.postProcess();
        //     processedSignature[invocationId] = sigProcessor.processedSig[invocationId];
        // })

        // Object.keys(invocationToClosureProxy).forEach((invocationId)=>{
        //     // Return if not leaf node
        //     if (trackOnlyLeaf && callGraph[invocationId].length) return;
        //     if (invocationId in nonCacheableNodes) return;
        //     var closureProxyHandler = invocationToClosureProxy[invocationId];
        //     var proxyPrivates = closureProxyHandler.accessToPrivates();
        //     var invocationSignature = {};
        //     invocationSignature[invocationId] = processedSignature[invocationId];
        //     if (!invocationSignature[invocationId]) return;
        //     var sigProcessor = new SignatureProcessor(invocationSignature, proxyPrivates.ObjectTree, callGraph, "closure");
        //     sigProcessor.process();
        //     // sigProcessor.postProcess();
        //     processedSignature[invocationId] = sigProcessor.processedSig[invocationId];
        // })

        // constructCacheReadKey();

        console.log("Done processing final signature\nStarting propagation...\n")

        //garbage cleaning
        // delete invocationToArgProxy;
        // delete globalProxyHandler;
        delete customLocalStorage;
        // delete invocationToClosureProxy;

        // sigProcessor.setPropagationData(PMD, {i2a:invocationToArgProxy, i2c:invocationToClosureProxy
        //     ,i2t: invocationToThisProxy, gph:globalProxyHandler}, processedSignature, nonCacheableNodes);
        // sigProcessor.signaturePropagate()

        console.log("Done propagating signatures..\nPurging expensive signatures");
        // purgeExpensiveSignatures();

    }


    var purgeExpensiveSignatures = function(){
        var topNodeInfo = runtimeInfo.filter(e=>e[2]>=0);
        var topNodes = topNodeInfo.map(e=>e[0]);
        var PERBYTEOVERHEAD = 1; //microsecond
        var node2invocations = {}, perInvocationTime = {};
        Object.keys(processedSignature).forEach((invoc)=>{
            var [n,count] = invoc.split("_count");
            if ( !(n in node2invocations) )
                node2invocations[n] = [];
            node2invocations[n].push(invoc);
        })

        topNodes.forEach((tN,ind)=>{
            var invocs = node2invocations[tN];
            if (!invocs){
                //the function never got instrumented for some reason
                return;
            }
            perInvocationTime[tN] = topNodeInfo[ind][2]*1000/invocs.length; //convert to microseconds
            invocs.forEach((i)=>{
                var sig = processedSignature[i];
                var sigSize = sig.reduce((acc, cur)=>{
                        var len =0;
                        if (typeof cur[1] == "string")
                            len += cur[1].length
                        if (cur[2] && typeof cur[2] == "string")
                            len += cur[2].length;
                        return len + acc},0);
                var predictedTime = PERBYTEOVERHEAD*sigSize;
                if (predictedTime > perInvocationTime[tN]){
                    runTimePurged += perInvocationTime[tN];
                    delete processedSignature[i];
                }
            })
        })
    }

    var _constructCacheReadKey = function(signature){
        var readString = "";
        // var readKeys = Object.keys(signature).filter(e=>e.indexOf("reads")>=0);
        var readKeys = [...new Set(signature.filter(e=>e[0].indexOf("reads")>0).map(e=>e[0]))];

        var constructReadKey = function(root, readArr){
            var key = "[`", props=readArr[1].split(";;;;"), value = readArr[2];
            props.forEach((p, ind)=>{
                if (ind === 0) return;
                key += p + "`]";
                if (ind != props.length-1) key +="[`"
            })
            //Special case window read
            if (readArr[0].indexOf(readArr[1])>=0){
                return "JSON.stringify(" + root + key + ") == " + ((root + key).split("[`self")[0]);
            }
            return "JSON.stringify(" + root + key + ") == " + value;
        }

        readKeys.forEach((readType,ind) =>{
            var _type = readType.split("_")[0];
            var root = "";
            switch(_type){
                case "argument":
                    root = "arg";
                    break;
                case "closure":
                    root = "closure";
                    break;
                case "this":
                    root = "thisObj";
                    break;
                case "global":
                    root = "window";
                    break;
            }
            signature.filter(e=>e[0]==readType).forEach((readArr,ind)=>{
                var r = constructReadKey(root, readArr);
                readString += r + " && ";
            })

        })

        return readString + " true";
    }

    var constructCacheReadKey = function(){
        Object.keys(processedSignature).forEach((invocId)=>{
            if (invocId in nonCacheableNodes) return;
            processedSignature[invocId].push(["finalRead", _constructCacheReadKey(processedSignature[invocId])]);
        })
    }

    var combineMultiSigs = function(sig, keyMap){
        var prevSig = JSON.parse(localStorage.getItem("signature"));
        var prevKeyMap = JSON.parse(localStorage.getItem("keyMap"));

        Object.keys(prevSig).forEach((key)=>{
            sig[key] = prevSig[key];
        })
        Object.keys(prevKeyMap).forEach((key)=>{
            keyMap[key] = prevKeyMap[key];
        })

    }

    var createSigProcWorker = function(procSig){
        var WORKERLIMIT = 8, workerList = [], workloads = [], len=Object.keys(procSig).length;
        var workloadSize = Math.floor(len/WORKERLIMIT), workerId=1;
        if (!workloadSize) {
            workloadSize = len, WORKERLIMIT=1;
        }
        console.log("Preparing data for workers...");
        for (var i=0;i<WORKERLIMIT*workloadSize;i+=workloadSize){
            var _wl = {}, _wlkeys;
            if ( i + workloadSize < WORKERLIMIT*workloadSize)
                _wlkeys = Object.keys(procSig).slice(i,i+workloadSize);
            else _wlkeys = Object.keys(procSig).slice(i, len);
            _wlkeys.forEach((k)=>{
                _wl[k] = procSig[k];
            })
            workloads.push(_wl);

            var worker  = new Worker("http://goelayu4929.eecs.umich.edu:99/hostSrc/signatureWorker.js");
            worker.addEventListener('message', function(e){
                var _id = workerId++;
                console.log("Data processed by worker " + _id);
                Object.keys(e.data.keymap).forEach((k)=>{
                    keysToStdKeys[k] = e.data.keymap[k];
                })
                // keysToStdKeys = keysToStdKeys.concat(e.data.keymap);
                Object.keys(e.data.sig).forEach((k)=>{
                    cacheableSignature[k] = e.data.sig[k];
                })

                if (_id == WORKERLIMIT){

                    var cacheExists = localStorage.getItem("fnCacheExists");
                    if (cacheExists){
                        combineMultiSigs(cacheableSignature, keysToStdKeys);
                    }
                    //Store the signature in local storage
                    localStorage.setItem("signature", JSON.stringify(cacheableSignature));
                    //store the uniq keys map
                    localStorage.setItem("keyMap", JSON.stringify(keysToStdKeys));
                    //store a small key to check whether a signature is available or not
                    localStorage.setItem("fnCacheExists",1);

                    //only the top window object should send the final alert
                    if (window.top == window)
                        console.log("Cache saved..");
                }
            })
            workerList.push(worker);
        }
        console.log("Data prepared, launching workers");
        workerList.forEach((w,i)=>{
            w.postMessage(workloads[i]);
        });


    }

    var storeSignature = function(){
        var strSignature = {};
        Object.keys(processedSignature).forEach((invocId)=>{
            if (invocId in nonCacheableNodes) return;
            processedSignature[invocId].IBF && (processedSignature[invocId].push(["IBF"].concat(processedSignature[invocId].IBF)) );
            (processedSignature[invocId].returnValue != null) && (processedSignature[invocId].push(["returnValue"].concat(processedSignature[invocId].returnValue)) );
            var strSig = JSON.stringify(processedSignature[invocId]);
            if (strSig && strSig instanceof Error) {
                nonCacheableNodes[invocId] = strSig.message;
                return;
            }
            else if (processedSignature[invocId] == "NonLeafNode") return;

            //convert the original signature in the string format, to do a memory comparison
            strSignature[invocId] = strSig;

        })

        createSigProcWorker(strSignature);

        // console.log(Object.keys(processedSignature).length + " coalesced into " + Object.keys(cacheableSignature).length);
    }

    this.storeSignature = storeSignature;

    this.processFinalSignature = processFinalSignature;

    // this.omni = omniStringifier;

    this.getKeysToStdKeys = function(){
        return keysToStdKeys;
    }

    this.getPMD = function(){
        return PMD;
    }

    this.getND = function(){
        return ND;
    }

    this.getCurRoot = function(){
        return curRoot;
    }

    this.addND = function(f){
        ND.push(f);
    }

    this.getRootInvocs = function(){
        return rootInvocs;
    }

    this.getRuntimePurged = function(){
        return runTimePurged;
    }

    this.getStoredSignature = function(){
        return cacheableSignature;
    }

    this.getInvocationToWrites = function(){
        return invocationToWrites;
    }

    var processInvocationProperties = function(){
        //Iterate processed signature instead of customLocalStorage object
        Object.keys(processedSignature).forEach((nodeId)=>{
            var propertyObj = processedSignature[nodeId];
            // if (!propertyObj.reads.length && !propertyObj.writes.length && !propertyObj.argProp) {
            //     // if (nodesByProperties.DOM.indexOf(nodeId)<0 && nodesByProperties.antiLocal.indexOf(nodeId)<0)
            //         nodesByProperties.NOGSNOARG.push(nodeId);
            // } else if ( (propertyObj.reads && propertyObj.reads.length) || ( propertyObj.writes && propertyObj.writes.length) ) {
            //     if (propertyObj.argProp && getFunctionStat(propertyObj.argProp) == "function")
            //         nodesByProperties.GS_f.push(nodeId);
            //     else nodesByProperties.GS.push(nodeId);
            // }
            // else {
            //     var argType = getFunctionStat(propertyObj.argProp);
            //     nodesByProperties.Function[argType].push(nodeId);
            // }
            if (nodesByProperties.antiLocal.indexOf(nodeId) < 0) {
                if (propertyObj.isFunction)
                    nodesByProperties.function.push(nodeId)
                else nodesByProperties.nonFunction.push(nodeId);
            }
        });
    }

    /* Proxy object handler */
    window.proxyReadCount =0; window.proxyWriteCount = 0;

    /*
    Declare your own inbuilt functions
    so that your instrumentation, doesn't end up calling the
    actual user defined code in cases when the user defined code
    has rewritten the in built functions
    */

    window.__tracerEval = window.eval;
    window.__tracerParseInt = window.parseInt;
    window.__tracerParseFloat = window.parseFloat;


    /*
    Rewrite inbuilt javascript APIs
    to support the use of proxy objects.
    Since lots of objects are wrapped in proxy,
    these objects can end up inside function calls outside my instrumented code
    And therefore we need to rewrite these definitions

    However, we don't need to rewrite these definitions during replay, when the page is
    replaying function signature from cache, since there are no proxy objects in memory

    */

    if (!pageLoaded) {


        function customShims(self){
            let _setProtoTypeof = Object.setPrototypeOf;
            self.Object.setPrototypeOf = function (obj, prototype) {
                if (prototype && prototype.__isProxy)
                    prototype = prototype.__target;
                return _setProtoTypeof(obj, prototype);
            }

            var _create = Object.create;
            self.Object.create = function(){
                var thisObj = this;
                for (var i=0;i<arguments.length;i++){
                    var arg = arguments[i];
                    if (arg && arg.__isProxy)
                        arguments[i] = arg.__target;
                }
                if (thisObj && thisObj.__isProxy)
                    thisObj = thisObj.__target;
                return _create.apply(thisObj,arguments);
            }

            var _encodeURI = window.encodeURI;
            self.window.encodeURI = function(uri){
                var _t;
                if (uri && (_t = uri.__target))
                    uri = _t;
                return _encodeURI.call(this, uri);
            }

            var _encodeURIComponent = window.encodeURIComponent;
            self.window.encodeURIComponent = function(uri){
                var _t;
                if (uri && (_t = uri.__target))
                    uri = _t;
                return _encodeURIComponent.call(this, uri);
            };

            var _getComputedStyle = window.getComputedStyle;
            self.window.getComputedStyle = function(){
                var thisObj = this;
                for (var i=0;i<arguments.length;i++){
                    var arg = arguments[i];
                    if (arg && arg.__isProxy)
                        arguments[i] = arg.__target;
                }
                if (thisObj && thisObj.__isProxy)
                    thisObj = thisObj.__target;
                return _getComputedStyle.apply(thisObj,arguments);
            };

            var _defineProperty = Object.defineProperty;
            self.Object.defineProperty = function(){
                for (var i=0;i<arguments.length;i++){
                    var arg = arguments[i];
                    if (arg && arg.value && arg.value.__isProxy)
                        arg.value = arg.value.__target;
                    if (arg && arg.__isProxy)
                        arguments[i] = arg.__target;
                }
                return _defineProperty.apply(this, arguments);
            }

            // var _toString = Object.prototype.toString;
            // self.Object.prototype.toString = function(){
            //     var thisObj = this;
            //     for (var i=0;i<arguments.length;i++){
            //         var arg = arguments[i];
            //         if (arg && arg.__isProxy)
            //             arguments[i] = arg.__target;
            //     }
            //     if (thisObj && thisObj.__isProxy)
            //         thisObj = thisObj.__target;
            //     return _toString.apply(thisObj,arguments);
            // }


            window.___ranCUSTOMSHIMS___ = true;
        };

        customShims(window);

        // --------------------------------------------------
        /***** HORCRUX *****/
        const DOMAccessHandler = {
            get: function(target, property, receiver) {
                if (property == '__isDOMNode') return true;

                const oldValue = Reflect.get(target, property);
                console.log(`called: ${property} on ${target} -> ${oldValue}`);
                return oldValue;
            }
        };

        const createDOMProxy = function(domObject, attachedToDOMTree) {
            if (pageLoaded || _shadowStackHead in nonCacheableNodes) return domObject;
            var nodeId = _shadowStackHead ? _shadowStackHead : null;
            if (!nodeId) {
                console.error('nodeId is null: THIS SHOULD NOT HAPPEN FOR HORCRUX!');
                return domObject;
            }
            if (domObject.__isProxy) {
                console.log('domObj is already a proxy!!');
                domObject = domObject.__target;
            }
            // console.log(`DOM Node: ${domObject}, attached: ${attachedToDOMTree}`);
            var proxyHandler = proxyEncapsulation(domObject, "DOM_NODE", null, attachedToDOMTree);
            var domProxy = new Proxy(domObject, proxyHandler);
            // TODO (Shaghayegh): Test/confirm if I should keep track of created DOM proxies!
            return domProxy;
        }

        // --------------------------------------------------

        /*Creates shim for every dom methods
        The purpose of the shim is to check for proxy argument types*/
        function createShimForDOMMethods(self){
            var HTMLNames = [
                "HTMLDocument", "HTMLLinkElement", "HTMLElement", "HTMLHtmlElement",
                "HTMLDivElement", "HTMLAnchorElement", "HTMLSelectElement",
                "HTMLOptionElement", "HTMLInputElement", "HTMLHeadElement",
                "HTMLSpanElement", "XULElement", "HTMLBodyElement", "HTMLTableElement",
                "HTMLTableCellElement", "HTMLTextAreaElement", "HTMLScriptElement",
                "HTMLAudioElement", "HTMLMediaElement", "HTMLParagraphElement", "DOMImplementation",
                "HTMLButtonElement", "HTMLLIElement", "HTMLUListElement", "HTMLIFrameElement",
                "HTMLFormElement", "HTMLHeadingElement", "HTMLImageElement", "IntersectionObserver",
                "HTMLStyleElement", "HTMLTableRowElement", "HTMLTableSectionElement", "PerformanceObserver",
                "HTMLBRElement", "Node", "EventTarget", "HTMLCollection", "MutationObserver", "Document",
                "HTMLCanvasElement", "CanvasRenderingContext2D", "CanvasGradient", "CanvasPattern",
                "ImageBitMap", "ImageData", "TextMetrics", "Path2D", "CSSCounterStyleRule", "Element",
                "RegExp", "Crypto", "Object", "Map", "MediaDevices","StorageManager","CacheStorage",
                "NodeList", "ChildNode"
            ];

            const DOMReadAPIs = ["getElementById", "getElementsByTagName",
                "getElementsByClassName", "getElementsByTagNameNS",
                "querySelector", "querySelectorAll",
                "compareDocumentPosition", "contains"
            ];

            // TODO: Handle "write", "writeln":
            // Wouldn't be useful to wrap the return value in a proxy, but at least should mark DOM_write
            const DOMWriteAPIs = ["insertBefore",
                "appendChild", "replaceChild", "removeChild", "remove",
                "insertAdjacentElement", "insertAdjacentHTML", "insertAdjacentText"
            ];

            HTMLNames.forEach((_class)=>{
                self[_class] && self[_class].prototype && Object.getOwnPropertyNames(self[_class].prototype).forEach((classKey)=>{
                    try {
                        if (typeof self[_class].prototype[classKey] == "function") {
                            var origMethod = self[_class].prototype[classKey];
                            if (classKey == "constructor") return;
                            self[_class].prototype[classKey] = function() {
                                var thisObj = this;
                                /***** HORCRUX *****/
                                // indicating whether the retVal is a node already attached to DOM tree or not
                                let attachedToDOMTree = false;
                                if (DOMWriteAPIs.includes(origMethod.name)) {
                                    // this object is attached to DOM tree.
                                    // so any changes to it affects the DOM  tree.
                                    if (thisObj && thisObj.__isAttachedToDOMTree) {
                                        customLocalStorage[_shadowStackHead]["DOM_write"] = true;
                                        attachedToDOMTree = true;
                                    }
                                    // TODO: change the corresponding field of arg proxy
                                    // if thisObject is already attached, the given arg is also getting
                                    // attached to the tree after this call
                                }

                                if (DOMReadAPIs.includes(origMethod.name))  {
                                    console.log(_shadowStackHead);
                                    customLocalStorage[_shadowStackHead]["DOM_read"] = true;
                                    attachedToDOMTree = true;
                                }
                                if (thisObj && thisObj.__isProxy)
                                    thisObj = thisObj.__target;
                                for (var i=0; i < arguments.length; i++){
                                    var arg = arguments[i];
                                    if (arg && arg.__isProxy)
                                        arguments[i] = arg.__target;
                                }

                                /*If regex testing, return the original method*/
                                if ( (origMethod.name == "test" || origMethod.name =="exec") && arguments[0] && arguments[0].__isShimmed__)
                                    arguments[0] = arguments[0].__orig__;

                                const retVal = origMethod.apply(thisObj, arguments);
                                /* For methods like "compareDocumentPosition" and "contains"
                                the returned value type is bitmask and boolean, respectively, so
                                it does not need to be wrapped in proxy! */
                                if (retVal && typeof retVal === "object") { //&& retVal.nodeType
                                    return createDOMProxy(retVal, attachedToDOMTree);
                                }
                                return retVal;
                            };
                            self[_class].prototype[classKey].__isShimmed__ = true
                            self[_class].prototype[classKey].__orig__ = origMethod;
                        }
                    } catch (e){};
                });
            });
        };
        createShimForDOMMethods(window);

        this.createShimForDOMMethods = createShimForDOMMethods;
        this.customShims = customShims;

        // Since we are modifying content of scripts, if scripts have dynamically created integrity attribute
        // the script won't be fetch as the hash match would fail, therefore make the integrity field non writable
        Object.defineProperty(HTMLScriptElement.prototype, "integrity",{value:"", writable:false})

        if (Error.captureStackTrace){
            var _captureStackTrace = Error.captureStackTrace;
            Error.captureStackTrace = function(){
                var args = arguments;
                if (args[0] && args[0].__target)
                    args[0] = args[0].__target;
                if (args[1] && args[1].__target)
                    args[1] = args[1].__target;
                return _captureStackTrace.apply(this, args);
            }
        }

        var _xmlSend = XMLHttpRequest.prototype.send;
            // override the native send()
        XMLHttpRequest.prototype.send = function(){
            if (_shadowStackHead){
                nonCacheableNodes[_shadowStackHead] = "xml";
                // console.log("xml request sent from " + _shadowStackHead);
            }
            // call the native send()
            _xmlSend.apply(this, arguments);
        }

        var origSetTimeout = window.setTimeout;
        // window.setTimeout = function(){
        //     if (arguments.length > 1 && !isNaN(Number.parseFloat(arguments[1]))){
        //         if (arguments[1] === 0){
        //             arguments[1] = 500;
        //         }
        //         arguments[1] = arguments[1]*4;
        //     }
        //     var thisArg = this;
        //     if (this && this.__isProxy){
        //         thisArg = this.__target;
        //     }
        //     return origSetTimeout.apply(thisArg, arguments);
        // }


        /*
        This takes care of every inbuild api invocation where
        the argument causes a different behavior due to the proxy wrapping
        for example: Object.prototype.toString.call(o);
        here if o is wrapped in proxy, it will always return object type
        */

        /*Not sure why we need these call exceptions*/
        var callExceptions = [/*"hasOwnProperty","toString","toLocaleString","isPrototypeOf"*/];
        var origCall = Function.prototype.call;
        Function.prototype.call = function() {
            var _t,n = this.__isProxy ? this.__target.name : this.name;
            if (arguments[0] && arguments[0].__isProxy)
                arguments[0] = arguments[0].__target;
            return origCall.apply(this, arguments);
        }
    } else {
        /*
        Even if the page is not loaded, increase the setTimeout value
        This is specially useful for the callgraph generation, where every function is instrumented
        Not needed anymore, since callgraph generation only uses tentative leaf nodes now

        */
        // var origSetTimeout = window.setTimeout;
        // window.setTimeout = function(){
        //     if (arguments.length > 1 && !isNaN(Number.parseFloat(arguments[1]))){
        //         if (arguments[1] === 0){
        //             arguments[1] = 500;
        //         }
        //         arguments[1] = arguments[1]*4;
        //     }
        //     return origSetTimeout.apply(this, arguments);
        // }
    }

    /*Create shim for performance entries so that all the other timers values are not returned*/

    // var _pGetEntries = window.performance.getEntries;
    // window.performance.getEntries = function() {
    //     var entries = _pGetEntries.apply(this, arguments);
    //     var relevantEntries = entries.filter(e=>e.name.indexOf("_count")<0);
    //     return relevantEntries;
    // }

    // var _pGetEntriesByType = window.performance.getEntriesByType;
    // window.performance.getEntriesByType = function(type){
    //     var entries = _pGetEntriesByType.apply(this, arguments);
    //     var relevantEntries = entries.filter(e=>e.name.indexOf("_count")<0);
    //     return relevantEntries;
    // }

    this.isPageLoaded = function(){
            return pageLoaded;
    }

    // use hacks to detect if a method is a DOM object or not
    // as sometimes even document objets are not instances of these parent objects
    // for reasons unknown
    // Despite window satisfying this criteria have this function return false for window
    // object specifically
    // Sometimes Node instances like character data or other nodes don't satisfy the instanceof check
    // therefore use specific methods like click and appendata
    var isDOMInheritedProperty = function(method){
        return method && (method instanceof EventTarget || method instanceof HTMLCollection || method instanceof NodeList || method.readState
            || method.click || method.appendData) &&  !(method instanceof HTMLDocument) /*&& (method && method.self != method)*/
    }

    /*Proxyobj is either a proxy object, or the window object when the this refers to window*/
    var handlePropagatedProxy = function(proxyObj,argInd, transferState, stackHead){
        var state = proxyObj.__isProxy || "global";
        var parentNodeId = proxyObj.__debug, proxyMap;
        switch (state) {
            case "argument" :
                proxyMap = invocationToArgProxy; break;
            case "global" :
                proxyMap = globalProxyHandler; break;
            case "this" :
                proxyMap = invocationToThisProxy; break;
            case "closure":
                proxyMap = invocationToClosureProxy; break;
        }
        var proxyPrivates = state == "global" ? globalProxyHandler : proxyMap[parentNodeId];
        if (!proxyPrivates) {
            /*Maybe the parent exists in different iframe*/
            nonCacheableNodes[parentNodeId] = "propagation error | can't store metadata"
            return;
        }
        var objId = proxyObj.__target != null ? proxyPrivates.accessToPrivates().getObjectId(proxyObj.__target) : [0]
        if (objId == null){
            console.error("Error while trying to propagate object from " + stackHead + " to " + parentNodeId);
            nonCacheableNodes[parentNodeId] = "propagation error | can't store metadata"
        }
        PMD[stackHead][transferState].push([argInd,objId[0],state]) // transferState(arguments or this) -> [objId of parent Object, argInd in case the object was passed as a specific index, state (which parent state it belonged to)]
    }

    // closure_id is only applicable when the type is closure
    var proxyEncapsulation =  function(rootObject, type, closure_id, attached) {

        var ObjectTree = {};
        var objectIdCounter = 1;
        var methodToProxy = new WeakMap();
        var proxyToMethod = new WeakMap();
        var ObjectToId = new WeakMap();
        var idToObject = {};
        var objectToPath;
        var parentFunctionId = null;
        var rootType = type;
        if (rootType == "argument" || rootType == "this" || rootType == "closure")
            parentFunctionId = _shadowStackHead;
        /***** HORCRUX *****/
        let isDOMNode = (rootType == "DOM_NODE");
        let attachedToDOMTree = !!attached;
        /* Initialize the object tree with window as the root object*/
        ObjectToId.set(rootObject,0);
        idToObject[0] = rootObject;
        ObjectTree[0] = {};

        var closureScope;
        if (type == "closure"){
            closureScope = `closure_${closure_id}`;
        }

        var appendObjectTree = function(rootId, key, childId){
            var _edge = ObjectTree[rootId];
            if (typeof key == "symbol")
                var ekey = "e_" + key.toString();
            else var ekey = "e_" + key;
            if (_edge) {
                if (!_edge[ekey])
                    _edge[ekey] = [];
                if (_edge[ekey].indexOf(childId)<0)
                    _edge[ekey].push(childId);
            }
            else {
                ObjectTree[rootId]  = {};
                var edge = ObjectTree[rootId];
                edge[ekey] = [];
                edge[ekey].push(childId);
            }
        }

        var stateAlreadyLogged = function(nodeId, logTup, logType){
            var otherLogType = logType.indexOf("reads")>=0 ? rootType+"_writes" : rootType +"_reads";
            var stateLogged = false;
            if (logType.indexOf("reads")>=0){
                //Test whether the value read is written inside the current function itself
                if (customLocalStorage[nodeId][otherLogType]) {
                    customLocalStorage[nodeId][otherLogType].forEach((el)=>{
                        if (el[0] == logTup[0] && el[1] == logTup[1])
                            stateLogged = true;
                    });
                    if (stateLogged) return stateLogged;
                }
            }

            customLocalStorage[nodeId][logType].forEach((tupEntry)=>{
                if (JSON.stringify(tupEntry) == JSON.stringify(logTup))
                    stateLogged = true;
            })
            return stateLogged;
        }

        var hasObjectId = function(obj){
            return ObjectToId.get(obj);
        }

        var getObjectId = function(obj){
            if (obj.__isClosureObj){
                return [0, false];
            }
            var rootId = ObjectToId.get(obj);
            if (rootId != null) return [rootId, false];
            rootId = objectIdCounter;
            objectIdCounter++;
            ObjectToId.set(obj, rootId);
            idToObject[rootId] =  obj;
            return [rootId,true];
        }

        var redundantStateConsumed = ["__isProxy", "top", "parent","toString","toJSON"];

        var loggerFunction = function(target, key, value, logType){
            var retCode = 0;

            var nodeId = _shadowStackHead ? _shadowStackHead : null;

            var stringifier = omniStringifier;
            var state = logType.split("_")[1] == "reads"  ? "read" : "write";
            if ( (!nodeId && logType.indexOf("global")<0 ) || (nodeId &&
                nonCacheableNodes[nodeId]) )
                return 1;

            var rootId = getObjectId(target)[0];

            if (state == "read"){
                if (value && value.__isProxy)
                    value = value.__target;
            }

            // if (logType.indexOf("argument")>=0 || logType.indexOf("this")>=0 || logType.indexOf("closure")>=0)
            //     nodeId = parentFunctionId;

            //This check implies that the function where the proxy is being accessed
            // is different from where it was created
            // therefore, add the log in both function signatures
            var currentObjectTree = null;
            var remoteLogType = "";
            // if (_shadowStackHead != nodeId) {
            //     // console.error("shadow stack head doesn't point to proxy creating head");
            //     //Check how in the current function, it is being accessed: as closure,argument, or this
            //     if ( invocationToArgProxy[_shadowStackHead] ){
            //         var remotePrivates = invocationToArgProxy[_shadowStackHead].accessToPrivates();
            //         if (remotePrivates.hasObjectId(target)) {
            //             currentObjectTree = remotePrivates.getObjectId;
            //             var remoteRootId = currentObjectTree(target);
            //             remoteLogType += "argument_" + logType.split('_')[1];
            //         }
            //     }
            //     if (!currentObjectTree && invocationToClosureProxy[_shadowStackHead]) {
            //         var remotePrivates = invocationToClosureProxy[_shadowStackHead].accessToPrivates();
            //         if (remotePrivates.hasObjectId(target)) {
            //             currentObjectTree = remotePrivates.getObjectId;
            //             var remoteRootId = currentObjectTree(target);
            //             remoteLogType += "closure_" + logType.split('_')[1];
            //         }
            //     }
            //     if (!currentObjectTree && invocationToThisProxy[_shadowStackHead]){
            //         var remotePrivates = invocationToThisProxy[_shadowStackHead].accessToPrivates();
            //         if (remotePrivates.hasObjectId(target)) {
            //             currentObjectTree = remotePrivates.getObjectId;
            //             var remoteRootId = currentObjectTree(target);
            //             remoteLogType += "this_" + logType.split('_')[1];
            //         }
            //     }
            // }

            var childId, childLogStr;
            if ((value instanceof Object) || (typeof value == "object" && value != null) || typeof value == "function") {
                var _childId = getObjectId(value);
                childId = _childId[0];

                // Only add to tree if the value is type object and it is a new object
                _childId[1] && appendObjectTree(rootId, key, childId);
                // if (currentObjectTree) {
                //     var remoteChildId = currentObjectTree(value);
                //     remotePrivates.appendObjectTree(remoteRootId, key, remoteChildId);
                // }

                if ( (logType.indexOf("reads")>=0) && typeof value != "function") {
                    childLogStr = childId;
                }

                if (state == "write"){
                    if (_shadowStackHead && (!value || !value.__isProxy)){
                        if (!invocationToWrites[_shadowStackHead])
                            invocationToWrites[_shadowStackHead] = []
                        invocationToWrites[_shadowStackHead].push(["broken-reference", childId ]);
                    }
                }
            }

            if (redundantStateConsumed.indexOf(key)>=0 || typeof key == "symbol")
                return 0;

            //HACK
            if (state == "write" && logType.indexOf("argument")>=0 && rootId === 0
                && value === null)
                return;


            // The only time when not having a nodeId is allowed, is when the logger function is closed for a
            // global read or write. However since the nodeId is not there, we won't be adding to any signature
            //only appending the object in the tree.
            //update: reads are important even when the value is undefined
            if (!nodeId ||  (_shadowStackHead != nodeId)) return 0;

            //if the value is the window object itself, log a special signature
            if (value && value.self == value) {
                customLocalStorage[nodeId].push([logType, rootId, key, childLogStr,0 ]);
                return 0;
            }

            // if (customLocalStorage[nodeId].length > sigSizeLimit){
            //     nonCacheableNodes[nodeId] = "signature size exceeds limit";
            // }


            // Doesn't make sense to log function reads, as I currently don't have a correct way of stringifying them
            if (!customLocalStorage[nodeId][logType])
                customLocalStorage[nodeId][logType]=[];
            if (logType.indexOf("reads")>=0) {
                if (logType.indexOf('closure') >=0 ) {
                    logType = `${closureScope}_reads`;
                    childLogStr = stringifier.stringify(value, state, 1);
                    if (childLogStr && childLogStr instanceof Error){
                        nonCacheableNodes[nodeId] = childLogStr.message;
                        return 1;
                    }
                    console.log(`---closure_reads value: ${childLogStr}---`);
                }
                var log = [logType, rootId, key, childLogStr, childId];
                customLocalStorage[nodeId].readKeys.add(logType);
                customLocalStorage[nodeId].push(log);
                // customLocalStorage[nodeId][logType].push(log);
            } else {
                if (logType.indexOf('closure')>=0)
                    logType = `${closureScope}_writes`;
                customLocalStorage[nodeId].writeKeys.add(logType);
                var log = [logType, rootId, key, childLogStr ];
                customLocalStorage[nodeId].push(log);
                // customLocalStorage[nodeId][logType].push(log);
                // if (customLocalStorage[nodeId].filter(e=>e[0].indexOf("reads")>=0 && e[3] === rootId).length)
                //     freezeReadState(nodeId);
            }
            return 0;
        }


        var _handleSymbolKey = function(target, key){
            if (!Reflect.get(target, key)){
                switch (key.toString()){
                    case 'Symbol(Symbol.toPrimitive)':
                        if (+target) return +target;
                        if (''+target) return ''+target;
                }
            }
        }

        var handleNonConfigurableProperty = function(target, key){
            var method = Reflect.get(target,key);
            // if (typeof method == "function")
            //     method = method.bind
            // if (_shadowStackHead)
            //     nonCacheableNodes[_shadowStackHead] = "non-configurable;" + key;
             return method;
        }

        var handleMetaProperties = function(target, key){
            switch(key){
                case 'apply' :
                    return Reflect.get(target, key);
                    break;
                case 'call':
                    return Reflect.get(target, key);
                    break;
                case 'bind':
                    return Reflect.get(target, key);
                    break;
            }
        }

        /*You can set the prototype of an object, there fore you need to track changes to prototype*/
        var outOfScopeProperties = [/*"location", "body", */"Promise", "top", "parent", "__proto__", "self",
        "getRegistration","digest", "query","getBattery"];

        var specialSetKets = ["prototype", "constructor","__proto__"];

        var applyTargetSpcl = ["RegExp", "DOMTokenList", "Performance", "CSSStyleDeclaration" ,"FontFace","Storage","String"];

        var nonConfigurableOnly = ["window"];

        var isWindow = function(obj,cors){
            if (obj && obj.self == obj){
                try{
                    if (obj.__isProxy) return obj;
                    var proxyPrivates = globalProxyHandler.accessToPrivates();
                    var _proxyMethod = proxyPrivates.methodToProxy.get(obj);
                    if (_proxyMethod) return _proxyMethod;
                    var proxyMethod = new Proxy(obj, handler);
                    proxyPrivates.methodToProxy.set(obj, proxyMethod);
                    return proxyMethod;
                } catch (e){
                    cors.v = true;
                    return obj;
                }
            }
        }

        // function isArguments( item ) {
        //     if (item && item.__isProxy)
        //         item = item.__target;
        //     return Object.prototype.toString.call( item ) === '[object Arguments]';
        // }

        function isArguments(thisArg, target){
            if (thisArg && thisArg.__target)
                thisArg = thisArg.__target;

            if (!thisArg.length) return false;


            return Array.from(thisArg).indexOf(target)>=0;
        }

        var handler = {
          get(target, key, receiver) {

            if (key == "__isProxy") return rootType;
            if (key == "__target") return target;
            if (key == "__debug") return parentFunctionId;
            if (key == "__isClosureObj") return target[key];
            /***** HORCRUX *****/
            if (key == "__isDOMNode") return isDOMNode;
            if (key == "__isAttachedToDOMTree") return attachedToDOMTree;

            var method = Reflect.get(target,key);

            /*Overwrites the custom toJson implementation, which might be doing something else
            instead of simply returning the original object*/
            if (key == "toJSON") return method;

            if (outOfScopeProperties.includes(key)) return method;
            var desc = customMethods.getOwnPropertyDescriptor(target, key);
            if (desc && desc.configurable == false && desc.writable == false/*&& nonConfigurableOnly.indexOf(key)>=0*/) {
                return handleNonConfigurableProperty(target, key);
            }
            // var isWinObj,cors={};
            // if (isWinObj = isWindow(method,cors)){
            //     // if (!cors.v) loggerFunction(target, key, method, rootType+"_reads");
            //     return isWinObj;
            // }

            /***** HORCRUX *****/
            /* Added the condition to filter out the reads related to local DOM nodes! */
            if (rootType != "DOM_NODE")
                _ret = loggerFunction(target, key, method, rootType + "_reads");

            if (method && method.__isProxy) {
                // if (rootType == "global" || method.__isProxy == "global")
                //     return method;

                // method = method.__target;
                // Sometimes the toString method doesn't exist on certain objects
                if (Object.prototype.toString.call(target).indexOf("Arguments")>=0 && _shadowStackHead)
                    handlePropagatedProxy(method,key, "argument",_shadowStackHead)
                method = method.__target
                //     return method;
                //     var actualMethod = method.__target;
                //     var childId = getObjectId(actualMethod);
                //     appendObjectTree(0, key, childId, ObjectTree);
                // } else if (target.__isClosureProxy) {
                //     var actualMethod = method.__target;
                //     var childId = getObjectId(actualMethod);
                //     appendObjectTree(0, key, childId, ObjectTree);

                // return method;
            }
            /* If method type if function, don't wrap in proxy for now */
            if (method && (typeof method === 'object' || typeof method === "function") && !outOfScopeProperties.includes(key)) {
                // if (isDOMInheritedProperty(method)) {
                // if (_shadowStackHead)
                //     nonCacheableNodes[_shadowStackHead] = "DOM";
                // return method;
                // }
              var desc = customMethods.getOwnPropertyDescriptor(target, key);
              if (desc && ! desc.configurable && !desc.writable) return handleNonConfigurableProperty(target, key);
              window.proxyReadCount++;
              // if (window.proxyReadCount % 1000000 == 0)
              //   alert("window.Proxyreadcount is " + window.proxyReadCount);
              // if (typeof method == "function") {
              //   var _method = method._bind(target);
              //   Object.setPrototypeOf(_method, method);
              //   if (!isNative(method))
              //       Object.assign(_method, method);
              //   return new Proxy(_method,);
              // }
              /*
              The following check is kind of inconsequental, cause even if you have a proxy around the method call or apply, the apply handler
              will be anyway called
              */
              if (key == "apply" || key == "call") return method;
              // console.log("Calling get of " + key + " and setting this to ");
              // console.log(target);
              var _proxyMethod = methodToProxy.get(method);
              if (_proxyMethod) return _proxyMethod;
                /***** HORCRUX *****/
                /* Example: if target is a DOM collection and key is an index
                returned element should also be a DOM node -- set isDOMNode and attachedToDOMTree
                */
                if (receiver.__isDOMNode && receiver.__isAttachedToDOMTree) {
                    customLocalStorage[_shadowStackHead]["DOM_read"] = true;
                    // TODO (Shaghayegh)? I'm not sure if I have to add this to the DOM map and if type DOM_NODE is ok
                    // test this with local variables
                    // var proxyHandler = proxyEncapsulation(method, "DOM_NODE", null, attachedToDOMTree);
                    // proxyMethod = new Proxy(method, proxyHandler);
                }
              // var proxyHandler = rootType == "global"  ? handler : _shadowStackHead ? invocationToProxy[_shadowStackHead][1] : handler;
              var proxyMethod = new Proxy(method, handler);
              methodToProxy.set(method, proxyMethod);
              return proxyMethod;
            } else {
              return method;
            }
          },
          set(target, key, value, receiver) {
            var cors={}, method;
            /***** HORCRUX *****/
            /* Added the second condition: filter out the writes related to local DOM nodes! */
            if (!isWindow(value, cors) && rootType != "DOM_NODE")
                loggerFunction(target, key, value, rootType + "_writes");
            window.proxyWriteCount++;
            if (specialSetKets.indexOf(key)>=0 && value && value.__isProxy){
                value = value.__target;
                return Reflect.set(target, key, value);
            }
            /* Example: if node is a global var, we want to capture: node.textContent = "..." */
            if (receiver.__isDOMNode && receiver.__isAttachedToDOMTree) {
                // console.log(`Updating the value of ${key} for an attached DOM node (${target.nodeName})!`);
                customLocalStorage[_shadowStackHead]["DOM_write"] = true;
            }
            /*The final value set should always be the actual value*/
            if (value && value.__isProxy) {
                // TODO (Shaghayegh):
                if (value.__isDOMNode) {
                    attachedToDOMTree = value.__isAttachedToDOMTree;
                    isDOMNode = value.__isDOMNode;
                }
                value = value.__target;
            }
            /*if rewriting closure object, rewrite the underlying object as well*/
            if (target.__isClosureObj){
                var setter = "set_"+key;
                target[setter](value);
            }
            return Reflect.set(target, key, value);
          },

          /*
          Let p be a proxy object. The following event handler will be called :
           - if p if a function itself, p(arg) : target -> p, thisArg -> window, args = args
           - if you do p.call or p.apply, first you go inside the get handler, read the value, and then go inside the apply handler

           We need function calls to be wrapped in proxy so that the thisArg can be properly handled.
           if target.name exists, then simply call the target using thisArg[target](...args) // Doesn't work because target.name might not a property of thisArg,
           otherwise follow the already implemented routine
          */

          apply (target, thisArg, args) {
                /*
                    If no thisArg, call it in the context of window ( this happens by default )
                    If the thisArg is a proxy object however it has no corresponding target method, call apply on the proxy object itself.
                    If the thisArg is not a proxy object, call the method on the thisArg itself.
                */

                // if (thisArg && (thisArg.__isClosureObj || isArguments(thisArg) ))
                //     thisArg = window
                // TODO
                // only remove proxies if the target is an inbuilt function
                // cause otherwise the propagation metadata would be incorrect
                if (args.length){
                        args.forEach((arg,_i)=>{
                            if (arg && arg.__isProxy)
                                args[_i] = arg.__target;
                        })
                }

                // if (target && target.name && thisArg[target.name])
                //     return thisArg[target.name](...args);

                if (thisArg && thisArg.__proto__ && ((thisArg.__proto__.constructor &&
                    applyTargetSpcl.indexOf(thisArg.__proto__.constructor.name)>=0) ||
                     thisArg.__target && thisArg.self == thisArg.__target) ){
                    // if (args.length){
                    //     args.forEach((arg,_i)=>{
                    //         if (arg && arg.__isProxy)
                    //             args[_i] = arg.__target;
                    //     })
                    // }
                    if (thisArg && thisArg.__target)
                        thisArg = thisArg.__target;
                }

                if (Reflect.apply.__isProxy)
                    Reflect.apply = Reflect.apply.__target;

                /*If target is indexed inside arguments, that means arguments was set as the
                thisObj due to instrumentation*/
                if (thisArg && (thisArg.__isClosureObj ))
                    thisArg = window

                /*Try catch can't catch certain errors, handle separately
                - thisArg of type permissions*/
                /*Permissions object*/
                if (thisArg && thisArg.__isProxy && thisArg.query)
                    thisArg = thisArg.__target;
                if (thisArg && thisArg.__isProxy && thisArg.getRegistration)
                    thisArg = thisArg.__target;
                if (thisArg && thisArg.__isProxy && thisArg.getBattery)
                    thisArg = thisArg.__target;
                if (thisArg && thisArg.__isProxy && thisArg.digest)
                    thisArg = thisArg.__target;

                if ( (target.name == "valueOf"  || target.name == "toString"  ||
                    target == Function.prototype.toString) && thisArg && thisArg.__target)
                    thisArg = thisArg.__target;

                try {
                    return Reflect.apply(target, thisArg, args);
                } catch (e){
                    if (thisArg && thisArg.__target)
                        return Reflect.apply(target, thisArg.__target, args);
                    throw e;
                }
          },
          construct (target, args, newPrototype) {
              if (newPrototype && newPrototype.__target)
                newPrototype = newPrototype.__target;
              return Reflect.construct(target, args, newPrototype);
          },
          setPrototypeOf (target, prototype) {
            if (prototype && prototype.__isProxy)
                prototype = prototype.__target;
            return Reflect.setPrototypeOf(target, prototype);
          },
          getPrototypeOf (target) {
            return Reflect.getPrototypeOf(target);
          },
          // getOwnPropertyDescriptor (target, propertyKey) {
          //   var r =  Reflect.getOwnPropertyDescriptor(target, propertyKey);
          //   loggerFunction(target, propertyKey, r, rootType + "_reads");
          //   return r;
          // },
          ownKeys (target) {
            return Reflect.ownKeys(target)
          },
          has (target, propertyKey) {
            return Reflect.has(target, propertyKey);
          },
          isExtensible (target) {
            return Reflect.isExtensible(target)
          },
          defineProperty (target, propertyKey, attributes) {
            if (attributes && attributes.__isProxy)
                attributes = attributes.__target;
            return Reflect.defineProperty(target, propertyKey, attributes);
          },
          deleteProperty (target, propertyKey) {
            return Reflect.deleteProperty(target, propertyKey);
          },
          preventExtensions (target) {
            return  Reflect.preventExtensions(target);
          },
          accessToPrivates (){
            return {ObjectTree: ObjectTree,getObjectId:getObjectId, appendObjectTree:appendObjectTree, hasObjectId:hasObjectId,
                    methodToProxy:methodToProxy, idToObject: idToObject}
          },

          getProcessedSignature (){
            var sigProcessor = new SignatureProcessor();
            sigProcessor.process();
            sigProcessor.postProcess();

            // // //Commenting out signature propogation for now
            // // //TODO
            sigProcessor.signaturePropogate();
            return sigProcessor.processedSig;
          }

        }

        return handler;
    }

    var globalProxyHandler = proxyEncapsulation(window,"global");

    var {proxy, revoke} = Proxy.revocable(window, globalProxyHandler);
    // Flag to disable proxy
    window.window = proxy;
    // window.window = window;
    globalProxyHandler.accessToPrivates().methodToProxy.set(window, proxy);

    if (pageLoaded){
        window.window = window;
    }

    this.getShadowStackHead = function(){
        return _shadowStackHead;
    }

    this.getNonCacheableFunctions = function() {
        // return Array.from(new Set(nonCacheableNodes));
        return nonCacheableNodes;
    }

    this.getCallGraph = function() {
        return callGraph;
    }

    this.getParentNodes = function(){
        return parentNodes;
    }

    this.getNonLeafNodes=function(){
        return nonLeafNodes;
    }

    this.getDC = function(){
        return domCounter;
    }

    this.updateDC = function(){
        domCounter++;
    }
    this.getInvocationProperties = function() {
        return nodesByProperties;
    }

    this.getTimingInfo = function(){
        return timingInfo;
    }

    this.getSigSizes = function(){
        return sigSizes;
    }

    this.setMutationContext = function(command, nodeId) {
        currentMutationContext = nodeId;
    }

	this.setGlobal = function (gthis) {
		globalThis = gthis;
	}

    this.getFunctions = function () {
        return functions;
    }

    this.getInvocations = function() {
        return invocationList;
    }

    this.getCacheStats = function () {
        return cacheStats;
    }

    this.getCustomCache = function() {
        return customLocalStorage;
    }

    this.getProcessedSignature = function() {
        return processedSignature;
    }

    this.setCustomCache = function(customCache) {
        this.customLocalStorage = customCache;
    }

    this.getObjectTree = function(){
        return ObjectTree;
    }

    this.getObjectToPath = function() {
        return objectToPath;
    }

    this.getObjectToId = function(){
        return ObjectToId;
    }

    var accumulateCache = function(nodeId) {
        var aggrCache = {};
        var lCallees = calleeMap[nodeId];

        var traverseChildren = function(nodeId) {
            var lCallees = calleeMap[nodeId];
            if (lCallees) {
                lCallees.forEach(function(callee){

                });
            }
        }
    }

    this.handleProtoAssignments = function(targetPrototype) {
        if (pageLoaded) return targetPrototype;
        if (targetPrototype && targetPrototype.__isProxy)
            return targetPrototype.__target;
        else return targetPrototype;
    }

    this.handleAssignments = function(assignment, assignee){
        return assignee;
    }

    this.handleTypeOf = function(obj){
        if (pageLoaded || _shadowStackHead in nonCacheableNodes)  return obj;
        var state,proxyMap,readInd, type;
        // return type;
        if (!pageLoaded && _shadowStackHead && obj && (state = obj.__isProxy)){
            switch (state) {
                case "argument" :
                    proxyMap = invocationToArgProxy; break;
                case "global" :
                    proxyMap = globalProxyHandler; break;
                case "this" :
                    proxyMap = invocationToThisProxy; break;
                case "closure":
                    proxyMap = invocationToClosureProxy; break;
            };
            var proxyPrivates = state == "global" ? globalProxyHandler : proxyMap[_shadowStackHead];
            if (!proxyPrivates) return obj;
            var objId = proxyPrivates.accessToPrivates().getObjectId(obj.__target);
            // if (objId[1]) throw new Error("typeof argument has no object id");
            if (objId[1]) return obj;
            type = typeof obj;
            customLocalStorage[_shadowStackHead].push([state+"_reads",objId[0], "typeof", type, type]);
            // if ( (readInd = customLocalStorage[_shadowStackHead].findIndex(e=>e[3]===objId[0])) >= 0)
                // customLocalStorage[_shadowStackHead].splice(readInd,1);

            return obj;
        }
        return obj;
    }

    this.handleComparison = function(obj, operator, value){
        if (pageLoaded || _shadowStackHead in nonCacheableNodes) return obj;
        var state, proxymap, type, readInd,cmpDelim = ";&;";
        if (_shadowStackHead && obj && (state = obj.__isProxy)){
            switch (state) {
                case "argument" :
                    proxyMap = invocationToArgProxy; break;
                case "global" :
                    proxyMap = globalProxyHandler; break;
                case "this" :
                    proxyMap = invocationToThisProxy; break;
                case "closure":
                    proxyMap = invocationToClosureProxy; break;
            };
            var proxyPrivates = state == "global" ? globalProxyHandler : proxyMap[_shadowStackHead];
            if (!proxyPrivates) return obj;
            var objId = proxyPrivates.accessToPrivates().getObjectId(obj.__target);
            if (objId[1]) return obj;

            var result;
            switch (operator){
                case "==": result = obj == value; break;
                case "===": result = obj === value; break;
                case "!=": result = obj != value; break;
                case "!==": result = obj !== value; break;
                case "instanceof": obj = target instanceof value; break;
                case "in": result = obj in value; break;
            }
            customLocalStorage[_shadowStackHead].push([state+"_reads",objId[0], operator+cmpDelim+result, value, value]);
            // if ( (readInd = customLocalStorage[_shadowStackHead].findIndex(e=>e[3]===objId[0])) >= 0)
            //     customLocalStorage[_shadowStackHead].splice(readInd,1);

            if (obj && obj.__isProxy) return obj.__target;
            else return obj;
        }
        if (obj && obj.__isProxy) return obj.__target;
        else return obj;
    }

    this.traversePath = function(path,params){
        var param,
            pathDelim = ";;;;";
        var state = path.split(pathDelim)[0],proxyMap;
            switch (state) {
                case "argument" :
                    param = params[0];break;
                case "global" :
                     param = window; break;
                case "this" :
                     param = params[2]; break;
                case "closure":
                    param = params[1];break;
            }
        path.split(pathDelim).forEach((prop, ind)=>{
            if (ind === 0) return;
            var len = path.split(pathDelim).length;
            if (param)
                param = param[prop];
        })
        return param;
    }

    this.getIdFromProxy = function(obj){
        if (pageLoaded) return null;
        var state, proxyMap;
        if (state = obj.__isProxy){
            switch (state) {
                case "argument" :
                    proxyMap = invocationToArgProxy; break;
                case "global" :
                    proxyMap = globalProxyHandler; break;
                case "this" :
                    proxyMap = invocationToThisProxy; break;
                case "closure":
                    proxyMap = invocationToClosureProxy; break;
            };
            var proxyPrivates = state == "global" ? globalProxyHandler : proxyMap[_shadowStackHead];
            if (!proxyPrivates) return;
            var objId = proxyPrivates.accessToPrivates().getObjectId(obj.__target);
            if (objId[1]) return null;

            return objId[0];
        }
    }

    this.getPathFromProxyId = function(id,state,nodeId){
        var proxyMap;
        switch (state) {
            case "argument" :
                proxyMap = invocationToArgProxy; break;
            case "global" :
                proxyMap = globalProxyHandler; break;
            case "this" :
                proxyMap = invocationToThisProxy; break;
            case "closure":
                proxyMap = invocationToClosureProxy; break;
        };
        var proxyPrivates = state == "global" ? globalProxyHandler : proxyMap[nodeId];
        var objectTree = proxyPrivates.accessToPrivates().ObjectTree;
        var objectToPath = {0:state};

        var constructPath = function(objectId){
            if (objectToPath[objectId]) return objectToPath[objectId];
            var path = "",  pathDelim = ";;;;";
            for (var nodeId in objectTree){
                for (var edge in objectTree[nodeId]) {
                    var _id = objectTree[nodeId][edge].indexOf(parseInt(objectId));
                    if (_id>=0) {
                        var parentPath = constructPath(nodeId);
                        path = parentPath + pathDelim + edge.substr(2);
                        objectToPath[objectId] = path;
                        return path;
                    }
                }
            }
            return path;
        }
        return constructPath(id);
    }

    this.handleProxyComparisons = function(...rhs){
        if (!rhs[0]) return rhs[0];
        if (rhs.length > 1 ) return rhs[rhs.length - 1];
        else if (rhs[0] && rhs[0].__isProxy) return rhs[0].__target;
        else return rhs[0];
    }

    this.isProxy = function(obj){
        if (pageLoaded) return obj;
        try {
            if (!obj || (typeof obj != "function" && typeof obj !="object")) return obj;
            if (obj.__isProxy) return obj.__target
            else return obj;
        } catch (e){
            return obj;
        }
    }

    this.logWrite = function(functionIdentifier, rhs, variableName, listOfProperties ){
        var key = variableName;
        if (listOfProperties.length > 0)
            key = _patchLogString(variableName, listOfProperties);
        customLocalStorage[functionIdentifier]["writes"][key] = rhs;
        return rhs;
    }

    var _patchLogString = function(input, varArray){
        var count = 0;
        var output = input.replace(/(\[).(\])/g, function(match, g1, g2, offset, string){
            var replaceString = varArray[count]
            if (typeof varArray[count] == "symbol")
                replaceString = varArray[count].toString();
            count++;
            return g1 + replaceString + g2;
        });
        return output
    }

    this.logRead = function(functionIdentifier, readArray, listOfProperties){
        var key = readArray[0]
        if (listOfProperties.length > 0)
            key = _patchLogString(readArray[0],listOfProperties)
        customLocalStorage[functionIdentifier]["reads"][key] = readArray[1];
        return readArray[1];
    }

    this.logThrowStatement = function(throwArg){
        var cacheIndex = _shadowStackHead ? _shadowStackHead : null;
        if (pageLoaded || !cacheIndex || nonCacheableNodes[cacheIndex]) return throwArg;
        var evalArg="";
        if (throwArg instanceof Error){
            evalArg += "new Error(" + JSON.stringify(escapeRegExp(throwArg.message)) + ")";
        } else evalArg = throwArg;
        var throwString = "throw " + evalArg;
        customLocalStorage[cacheIndex]["IBF"] += "\n" + throwString + "\n";
        return throwArg;
    }

    var cleanUpReturnValue = function(ret,ind, seenObjs){
        try {
            switch (typeof ret) {
                case "object" :
                    if (!ret || seenObjs.indexOf(ret)>=0)
                        return;
                    /*check for window object*/
                    if (ret && ret.self == ret)
                        return;
                    if (ind === -1) {
                        seenObjs.push(ret);
                    } else {
                        if (!ret[ind] || ret[ind].self == ret[ind]){
                            return;
                        }
                        else if (ret[ind].__isProxy)
                            ret[ind] = ret[ind].__target;
                        seenObjs.push(ret[ind]);
                        ret = ret[ind];
                    }
                        if (Array.isArray(ret)){
                        for (var _i = 0, _len = ret.length; _i < _len; _i++) {
                            cleanUpReturnValue(ret,_i, seenObjs);
                        }
                    } else {
                        /*o.keys returns enumerable properties only
                        not sure if we need to rewrite non enumerable properties as well*/
                        var propNames = Object.keys(ret);
                        for (var k of propNames ){
                            cleanUpReturnValue(ret,k, seenObjs);
                        }
                    }
                    break;
                case "function":
                    if (ind === -1) {
                    } else if (ret[ind] && ret[ind].__isProxy)
                        ret[ind] = ret[ind].__target;
                default: break;
            }
            return;
        } catch (e){
            return;
        }
    }

    this.logReturnValue = function(functionIdentifier, returnValue, params) {
        var cacheIndex = functionIdentifier + "_count" + invocationsIndName[functionIdentifier];
        var cacheIndex = _shadowStackHead ? _shadowStackHead : null;
        if (pageLoaded || !cacheIndex || nonCacheableNodes[cacheIndex]) return returnValue;
        // if (isDOMInheritedProperty(returnValue)){
        //     nonCacheableNodes[cacheIndex] = "DOM";
        //     //Don't need to reset shadow stack head as the exit function is already called
        //     // hence the shadow stack head no longer points to the current function
        //     // _shadowStackHead = null;
        //     // this.exitFunction(functionIdentifier, params);
        //     return returnValue;
        // }
        // return returnValue;
        // var _retString = omniStringifier.stringify(returnValue,"read",2);
        // if (_retString && _retString instanceof Error) {
        //         nonCacheableNodes[cacheIndex] = _retString.message;
        // }
        // /*If the return value couldn't be stringified, doesn't matter. The function is marked as uncacheable anyway*/
        // if (customLocalStorage[cacheIndex]) customLocalStorage[cacheIndex]["returnValue"] = _retString;

        var seenObjs = [];
        if (returnValue && returnValue.__isProxy)
            returnValue = returnValue.__target;
        return cleanUpReturnValue(returnValue, -1,seenObjs), returnValue;
    }

    var logNonProxyParams = function(nodeId,params){
        for(var i in params) {
                if (params[i] != null && !params[i].__isProxy && typeof params[i] != "function")
                    var strParam =  stringify(params[i]);
                 if (strParam && strParam.__proto__.__proto__ == "Error") return
                 customLocalStorage[nodeId].arguments.before[i] = strParam;
        }
    }


    var mergeObjects = function(src, dst){
        for (var property in src) {
            dst[property] = src[property];
        }
    }

    var replay_arg = (log, arg,cmp,params) => {
        var result = true;
        var prop = log[1], value = log[2];
        // if (!cmp){
        //     if (typeof value == "object")
        //         value = value[0];
        //     else value = omniStringifier.parse(value,params);
        // }
        result = result && traverseToTarget(arg, prop, value,cmp);
        return result;
    };

    var getChildAccessor = function(log, params, path2function){
        var fnRoot;
        var fnScope = path2function.split(';;;;')[0],fnKey = path2function.split(';;;;').slice(1,);
        switch (fnScope){
            case "global": fnRoot = window; break;
            case "argument":fnRoot = params[0];break;
            case "closure":fnRoot = params[1];break;
            case "this": fnRoot = params[2];break;
        }
        var fnkeyLen = fnKey.length;
        fnKey.forEach((key)=>{
            fnRoot = fnRoot[key];
        })
        return fnRoot;
    }

    var replay_childClosure = function(log,arg,cmp,params){
        var tokens = log[1].split(";&;")
        var [path2function,prop] = [tokens.slice(0,tokens.length-1),tokens[tokens.length-1]],
            value = log[2], fnRoot;
        // if (!cmp) {
        //     if (typeof value != "object")
        //         throw new Error("Can't replay child closure where value is a reference");
        //     value = value[0]
        // }
        var newParams = [...params];
        var fnRoot;
        path2function.forEach((path)=>{
            fnRoot = getChildAccessor(log, newParams, path);
            var scopeObj = fnRoot.__getScope__();
            //update the closure scope
            //if path2function has more than 2 entries, then the second one
            // has to be a closure, so update the closure params
            newParams[1] = scopeObj
        })
        var accessor = cmp ? "__get__" : "__set__";
        return fnRoot[accessor](prop,value)
    }

    var replay_childIBF = function(log, params){
        var fnRoot = getChildAccessor(log, params);
        fnRoot["__replayIBF__"](log[2]);
    }

    var replay_closure = (write_array, closure,cmp) => {
        var result = true;
        write_array.forEach((write_log)=>{
            var prop = write_log[0], value = write_log[1];
            result = result &&  traverseToTarget(closure, prop, value,cmp);
            // target = omniStringifier.parse(value);
            // eval(write_log);
        })
        return result;
    };
    var replay_this = (write_array, thisObj,cmp) => {
        var result = true;
        write_array.forEach((write_log)=>{
            var prop = write_log[0], value = write_log[1];
            result = result &&  traverseToTarget(thisObj, prop, value,cmp);
            // target = omniStringifier.parse(value);
            // eval(write_log);
        })
        return result;
    }
    var replay_global = (write_array, global,cmp) => {
        var result = true;
        write_array.forEach((write_log)=>{
            var prop = write_log[0], value = write_log[1];
            result = result &&  traverseToTarget(global, prop, value,cmp);
            // target = omniStringifier.parse(value);
            // eval(write_log);
        })
        return result;
    }

    var replay_IBF = (IBFs, arg, closure, thisObj) => {
        eval(IBFs);
    }

    this.replay_IBF = replay_IBF;

    var comparisonOperators = ["==","!=","===","!==","instanceof","in"]

    var specialMatchingPaths = ["localStorage","cookie"]

    var traverseToTarget  = function(root, path,value,cmp){
        var target = root,
            pathDelim = ";;;;", result = !cmp, opIndex = -1,
            cmpDelim = ";&;";
        path.split(pathDelim).forEach((prop, ind)=>{
            if (ind==0) return;
            var len = path.split(pathDelim).length;
            if ( target && (ind == len-1 || prop == "typeof")) {
                if (cmp){
                    if (specialMatchingPaths.indexOf(prop)>=0)
                        result = true;
                    else if (prop == "typeof")
                        result = typeof target == value;
                    else if (prop == "self")
                        result = target[prop] == target;
                    else if (prop.indexOf(cmpDelim)>=0) {
                        if ((opIndex = comparisonOperators.indexOf(prop.split(cmpDelim)[0]))>=0) {
                            var cmpOut = prop.split(cmpDelim)[1] === 'true';
                            switch (comparisonOperators[opIndex]){
                                case "==": result = (target == value) == cmpOut; break;
                                case "===": result = (target === value) == cmpOut; break;
                                case "!=": result = (target != value) == cmpOut; break;
                                case "!==": result = (target !== value) == cmpOut; break;
                                case "instanceof": result = (target instanceof value) == cmpOut; break;
                                case "in": result = (target in value) == cmpOut; break;
                            }
                        }
                    }
                    else {
                        if (typeof value == "string"){
                            var [Ovalue, Otype, Olen] = value.split(';;&;;');
                            if (Otype){
                                Olen = Number.parseInt(Olen);
                                if (Otype == "array" ) {
                                    if (!Array.isArray(target[prop]))
                                        result = false;
                                    else if (Olen != target[prop].length)
                                        result = false;
                                    else {
                                        var [tval,_,__] = omniStringifier.stringify(target[prop],"read").split(';;&;;');
                                        result = tval == Ovalue;
                                    }
                                } else if (Otype == "object"){
                                    if (typeof target[prop] != "object")
                                        result = false;
                                    else if (target[prop] && Object.keys(target[prop]).length != Olen)
                                        result = false;
                                    else {
                                        var [tval,_,__] = omniStringifier.stringify(target[prop],"read").split(';;&;;');
                                        result = tval == Ovalue;
                                    }
                                }
                            }
                            else {
                                var tval = omniStringifier.stringify(target[prop],"read")
                                if (typeof tval == "string")
                                    result = tval.split(';;&;;')[0] == Ovalue;
                                else result = target[prop] == Ovalue;
                            }
                        }
                        else {
                            result = target[prop] == value[0];
                        }
                    }
                }
                else {
                    if (target.__isClosureObj){
                        target["set"+prop](value)

                    } else {
                        target[prop] = (value);
                    }
                    result = true;
                }
            } else if (target)
                target = target[prop];
        })
        return result;
    }

    this.traverseToTarget = traverseToTarget;

    var verifyAndReplayCache = function(cacheIndex,writeObj) {
        //Replay all the non global writes speculatively
        var sig = processedSignature[cacheIndex];
        if (Object.prototype.toString.call(writeObj).indexOf("Arguments")>=0)
            replay_arg(sig.argument_writes, writeObj);
        else if (writeObj.__isClosureProxy)
            replay_closure(sig.closure_writes, writeObj);
        else replay_this(sig.this_writes, writeObj);
    }

    var getArgTypes = function(args, delim){
        var argTypes = "";
        for (var a of args)
            argTypes += typeof a + delim;
        return argTypes;
    }

    var exceedsInvocationLimit = function(nodeId){
        return nodeId.split("_count")[1] > INVOCATION_LIMIT;
    }

    this.cacheInit = function(nodeId, isRoot){
        if (invocationsIndName[nodeId] != null)
            invocationsIndName[nodeId]++;
        else invocationsIndName[nodeId] = 0;

        var cacheIndex = nodeId + "_count" + invocationsIndName[nodeId];
        // invocationList.push(cacheIndex);


        // if (instrumentationPattern == "cg"){
        //     var _e = new Error;
        //     var sd = _e.stack.split('\n');
        //     if (sd.length == 4)
        //         isRoot = true;
        // }
        // if (isRoot)
        //     rootInvocs.push(cacheIndex);

        // timingInfo[cacheIndex].push(window.performance.now());
        if (instrumentationPattern == "record" || instrumentationPattern == "replay") {

            callGraph[cacheIndex] = [];
            customLocalStorage[cacheIndex] = []

            if (_shadowStackHead) {
                callGraph[_shadowStackHead].push(cacheIndex)
                // insert placeholder for children signature
                // if (customLocalStorage[_shadowStackHead])
                customLocalStorage[_shadowStackHead].push(cacheIndex)
                // Before entering child function, freeze the state of the parent function
                // freezeReadState(_shadowStackHead);
            } else {
                parentNodes.push(cacheIndex);
            }

            shadowStack.push(cacheIndex);
            _shadowStackHead = cacheIndex;

            PMD[cacheIndex] = {argument:[],this:[],closure:[]}

            // if (invocationsIndName[nodeId] > INVOCATION_LIMIT ){
            //     nonCacheableNodes[cacheIndex] = "INVOCLIMIT";
            //     // _shadowStackHead = null;
            //     // window.performance.mark(cacheIndex);
            //     // timingInfo[cacheIndex].push(window.performance.now());
            //     return;
            // }
            customLocalStorage[cacheIndex]["IBF"] = "";
            customLocalStorage[cacheIndex].CFG = [];
            customLocalStorage[cacheIndex]["ec"] = window && window.document ?
                window.document.location.href : null;
            customLocalStorage[cacheIndex].readKeys = new Set();
            customLocalStorage[cacheIndex].writeKeys = new Set();
            // customLocalStorage[cacheIndex].startTime = window.performance.now();
        } else {
            // if (!(cacheIndex in callGraph))
            timingInfo[cacheIndex] = [];
            timingInfo[cacheIndex].push(window.performance.now());

            callGraph[cacheIndex] = [];
            if (_shadowStackHead) {
                callGraph[_shadowStackHead].push(cacheIndex)
            } else {
                rootInvocs.push(cacheIndex);
                curRoot = cacheIndex;
            }


            shadowStack.push(cacheIndex);
            _shadowStackHead = cacheIndex;
        }
        // window.performance.mark(cacheIndex);
    }

    var checkForCacheHit = function(sig,arg,closure,thisObj){
        try {
            var evalString = sig.filter(e=>e[0]=="finalRead")[0][1];
            // evalString = evalString.split("&&").slice(0,2).join("&&");
            var CHF = new Function('arg,closure,thisObj','return ' + evalString);
            return CHF(arg,closure,thisObj) && false;
            return false;
        } catch (e) {
            throw new Error("Error while determining cache hit status");
        }
    }

    /*
    Depending on value of cmp, will compare of execute the given state
    if cmp is true will compare and return the result otherwise execute
    state : Signature of the function who's state has to be compared
    Returns true when executing state, and for compare will return the result of comparing the state
    */
    var compareOrExecuteState = function(sig,cmp, ...params){
        var fn = replay_arg, param = null
            result = true;
        var delim = cmp ? "_reads" : "_writes";
        // var sig = sig.filter(e=>e[0].indexOf(delim)>=0);
        var keys = [...new Set(sig.map(e=>e[0]))];
        var scInd = 0, ind=0; //short-circuit index;
        for (entry of sig){
        // sig.forEach((entry,ind)=>{
            var type = entry[0];
            var state = entry[0].split(delim)[0],proxyMap;
            fn = replay_arg;
            switch (state) {
                case "argument" :
                    param = params[0];break;
                case "global" :
                     param = window; break;
                case "this" :
                     param = params[2]; break;
                case "closure":
                    param = params[1];break;
                case "childClosure":
                    fn = replay_childClosure;break
            }
            result = result && fn(entry,param, cmp,params);
            ind++;
            scInd = ind;
            if (cmp && !result)
                return [result,scInd];
        }

        return [result,scInd];
    }

    var preProcessWrites = function(writeSig, returnValue, params){
        writeSig.forEach((entry)=>{
            if (typeof entry[2] == "object")
                entry[2] = entry[2][0];
            else entry[2] = omniStringifier.parse(entry[2],params);
        })

        if (returnValue && returnValue.length != 3){
            returnValue[1] =  omniStringifier.parse(returnValue[1],params);
        }
    }

    /*
    Returns an array
    [cacheHit, return value]
    params : argument, closure, this
    */

    this.cacheAndReplay = function(nodeId, ...params){
        // return [false,null];
        // var cacheIndex = _shadowStackHead ? _shadowStackHead : null;
        var cacheIndex = nodeId + "_count" + invocationsIndName[nodeId];
        // if (skipReplay){
        //     cacheStats.misses.empty.push(cacheIndex);
        //     return [false, null]
        // }
        if (invocationsIndName[nodeId] > INVOCATION_LIMIT){
            cacheStats.misses.empty.push(cacheIndex);
            return [false,null];
        }
        var sig, returnValue = [];
        // return [false,null];
        // timingInfo[cacheIndex]=[];
        // timingInfo[cacheIndex].push(window.performance.now());
        if (sig = processedSignature[keysToStdKeys[cacheIndex]]) {
            // return []
            if (!sig.length){
                cacheStats.misses.empty.push(cacheIndex);
                // timingInfo[cacheIndex].push(window.performance.now());
                return [false, null];
            }
            try {
                /*Iterate sig once and seperate different parts*/
                var ibf, childIBF, _ret, readSig=[], writeSig=[],ret;
                for (_e of sig){
                    if (_e[0].indexOf("_reads")>=0)
                        readSig.push(_e);
                    else if (_e[0].indexOf("_writes")>=0)
                        writeSig.push(_e);
                    else if (_e[0] == "IBF")
                        ibf = _e;
                    else if (_e[0]== "childIBF")
                        childIBF = _e;
                    else if (_e[0] == "returnValue")
                        _ret = _e;
                }
                var readStateMatch = compareOrExecuteState(readSig,true,...params);
                if (readStateMatch[0]) {
                    // cacheStats.hits.push(cacheIndex);
                    // timingInfo[cacheIndex].push(window.performance.now());
                    var _wP = writeStateProcessed.get(sig);
                    if (_wP === undefined){
                        try {
                            preProcessWrites(writeSig, _ret, params);
                        } catch (e){
                            writeStateProcessed.set(sig, false);
                            throw e;
                        }
                    } else if (_wP === false){
                        cacheStats.misses.mismatch.push(cacheIndex);
                        return [false, null];
                    }
                    writeStateProcessed.set(sig, true);
                    compareOrExecuteState(writeSig,false,...params)
                    // _i = sig.filter(e=>e[0] == "IBF");
                    if (ibf){
                        // return [false, null];
                        replay_IBF(ibf[1],...params);
                    }
                    // _i = sig.filter(e=>e[0] == "childIBF")
                    if (childIBF)
                        replay_childIBF(childIBF[1],params)
                    // compareOrExecuteState(sig,false,...params)
                    // var _ret = sig.filter(e=>e[0] == "returnValue"),ret;
                    if (_ret){
                        // if (_ret.length == 3)
                        ret = _ret[1];
                        // else ret = omniStringifier.parse(_ret[1],params);
                    }
                    cacheStats.hits.push(cacheIndex);
                    // timingInfo[cacheIndex].push(window.performance.now());
                    // sigSizes[cacheIndex]=sig.reduce((acc, cur)=>{
                    //     var len =0;
                    //     if (typeof cur[1] == "string")
                    //         len += cur[1].length
                    //     if (cur[2] && typeof cur[2] == "string")
                    //         len += cur[2].length;
                    //     return len + acc},0);
                    return [true,ret];
                } else {
                    cacheStats.misses.mismatch.push(cacheIndex);
                    // timingInfo[cacheIndex].push(window.performance.now());
                    // var _ind = readStateMatch[1];
                    // sigSizes[cacheIndex]=sig.slice(0,_ind).reduce((acc, cur)=>{
                    //     var len =0;
                    //     if (typeof cur[1] == "string")
                    //         len += cur[1].length
                    //     if (cur[2] && typeof cur[2] == "string")
                    //         len += cur[2].length;
                    //     return len + acc},0);
                    return [false, null];
                }
            } catch (e) {
                if (ibf && ibf.length && ibf[0][1].indexOf("throw ")>=0){
                    cacheStats.hits.push(cacheIndex);
                    // timingInfo[cacheIndex].push(window.performance.now());
                    // sigSizes[cacheIndex]=sig.reduce((acc, cur)=>{
                    //     var len =0;
                    //     if (typeof cur[1] == "string")
                    //         len += cur[1].length
                    //     if (cur[2] && typeof cur[2] == "string")
                    //         len += cur[2].length;
                    //     return len + acc},0);
                    throw e;
                }
                cacheStats.misses.error.push([cacheIndex,e.message]);

                // if (e.message && e.message.indexOf("OMNI")<0) throw e;
                // cacheStats.hits.pop();
                // timingInfo[cacheIndex].push(window.performance.now());
                return [false,null];
            }
        }
        cacheStats.misses.empty.push(cacheIndex);
        // timingInfo[cacheIndex].push(window.performance.now());
        return [false,null];
    }

    var getRootIds = function(readArr){
        var ids = [];
        /*If the 4th index is string, it means the read has been processed already
        however if the logType is write, then add it regardless*/
        readArr.forEach((read)=>{
            if (typeof read[3] != "string" ||
                read[3].indexOf("__func__source")>=0 ||
                read[0].indexOf("_write")>=0)
                ids.push(read[1]);
        })
        // return [...new Set(ids)];
        return ids;
    }

    var filterSignature = function(e, roots, writes, key){
        if (e[0] != key) return true;
        var rootInd = roots.indexOf(e[4]);
        if (rootInd>=0){
            roots.splice(rootInd, 1);
            return false;
        }
        var writeInd = writes.indexOf(e[4]);
        if (writeInd>=0){
            writes.splice(writeInd,1);
            return false;
        }
        return true;
    }

    var uniqueSignature = function(sig){
        var strSig = sig.map(e=>JSON.stringify(e));
        var uS = new Set(strSig);
        var uniqueArr = [...uS].map(e=>JSON.parse(e));
        return uniqueArr;
    }

    var freezeReadState = function(nodeId){
        if (nodeId in nonCacheableNodes) return;
        var signature = customLocalStorage[nodeId];
        if (signature == null) return;
        if (signature.length > sigSizeLimit) {
            nonCacheableNodes[nodeId]="signature size exceeded capacity";
            return;
        }
        // signature = uniqueSignature(signature);
        // var readKeys = [...new Set(signature.filter(e=>e[0].indexOf("reads")>0).map(e=>e[0]))];
        var readKeys = signature.readKeys;
        readKeys.forEach((key)=>{
            var state = key.split("_reads")[0],proxyMap;
            var currStateWrites = invocationToWrites[nodeId] ? invocationToWrites[nodeId].filter(e=>e[0]==state).map(e=>e[1]) : [];
            switch (state) {
                case "argument" :
                    proxyMap = invocationToArgProxy; break;
                case "global" :
                    proxyMap = globalProxyHandler; break;
                case "this" :
                    proxyMap = invocationToThisProxy; break;
                case "closure":
                    proxyMap = invocationToClosureProxy; break;
            }
            var rootObjects = getRootIds(signature.filter(e=>e[0].split("_")[0]==state));
            // customLocalStorage[nodeId] = signature.filter((e)=> { return e[0] != key ||
            //     (rootObjects.indexOf(e[4])<0 && currStateWrites.indexOf(e[4])<0)} );
            //Disable filtering of signature entriesinde
            // customLocalStorage[nodeId] = signature.filter((e)=>{return filterSignature(e, rootObjects, currStateWrites, key)});
            (signature.returnValue != null) && (customLocalStorage[nodeId].returnValue = signature.returnValue)
            signature.IBF && (customLocalStorage[nodeId].IBF = signature.IBF)
            customLocalStorage[nodeId].ec = signature.ec
            customLocalStorage[nodeId].readKeys = signature.readKeys;
            customLocalStorage[nodeId].writeKeys = signature.writeKeys;
            signature = customLocalStorage[nodeId];
            signature.forEach((readArr,ind)=>{
                if (typeof readArr[3] == "number" && readArr[0] == key){
                    var proxyPrivates = state == "global" ? globalProxyHandler : proxyMap[nodeId];
                    var obj = proxyPrivates.accessToPrivates().idToObject[readArr[3]];
                    if (!obj) console.error("Object not found during freezing read state");
                    var str = omniStringifier.stringify(obj,"read",1);
                    if (str){
                        if (str instanceof Error){
                            nonCacheableNodes[nodeId] = str.message;
                            return 1;
                        }
                        if (str.length > OMNI_SIZE_LIMIT){
                            nonCacheableNodes[nodeId] = "Value exceeded OMNI_SIZE_LIMIT";
                            return 1;
                        }
                    }
                    signature[ind] = [readArr[0], readArr[1], readArr[2], str, null];
                }
            })
        })
    }

    this.exitFunction = function(nodeId, enableRecord){
        // var cacheIndexExp = nodeId + "_count" + invocationsIndName[nodeId];
        var cacheIndex = _shadowStackHead ? _shadowStackHead : null;
        if (!cacheIndex) return;

        if (instrumentationPattern == "cg")
                timingInfo[cacheIndex].push(window.performance.now());

        if (instrumentationPattern == "replay")
            return;
        shadowStack.pop();
        if (shadowStack.length)
            _shadowStackHead = shadowStack[shadowStack.length - 1];
        else {
            _shadowStackHead = null;
        }

    }

    this.logBranchTaken = function(nodeId, branchInfo){
        var cacheIndex = _shadowStackHead ? _shadowStackHead : null;
        if (!cacheIndex) return;
        customLocalStorage[cacheIndex].CFG.push(branchInfo);
    }

    this.updateClosureCache = function(cacheIndex, closureObj){
        Object.keys(closureObj).forEach((k)=>{
            if (typeof closureObj[k] != "object"){
                var writeAr = [0, k, closureObj[k]];
                customLocalStorage[cacheIndex]["closure_writes"].push(writeAr);
            }
        })
        return;
    }

    this.dumpArguments = function(nodeId, params) {
        // functionTimerE[nodeId] = performance.now();
        // window.sigStack[nodeId].push(functionTimerE[nodeId] - functionTimerS[nodeId]);
        // return;
        if (customLocalStorage[nodeId]["arguments"])
            customLocalStorage[nodeId]["arguments"]["after"] = params;
        shadowStack.pop();
    }

    this.logCallee = function(callee, calleeRes){
        if (callee && callee.toString){
            var _isNative = isNative(callee.toString());
            if(!_isNative){
                if (!_shadowStackHead)
                    throw new Error("no shadow stack found");
                nonLeafNodes.push(_shadowStackHead);
            }
        } else {
            console.error(callee + " no toString method for object");
        }
        return calleeRes;
    }

    this.logIBF = function(functionId, IBF, callee, IBFStrDecl, IBFStrCall, argStrs, argVals){
        if (callee && callee.toString){
            var actualCallee = callee;
            if (callee.__isProxy) actualCallee = callee.__target;
            var _isNative = isNative(Object.prototype.toString.call(actualCallee));
            if (!_isNative && !actualCallee.__isShimmed__) {
                if (callee.__isProxy){
                    var childLen = callGraph[_shadowStackHead].length;
                    if (childLen) {
                        var stackHead = callGraph[_shadowStackHead][childLen-1]
                        handlePropagatedProxy(callee, null, "closure",stackHead)
                    }
                }
                return IBF;
            }
        } else {
            // TODO callee has no string method, can't store metedata information
            // console.error("Callee has no toString method")
        }
        var ibfStr = IBFStrCall, argsConverted = [],val;
        // var cacheIndex = functionId + "_count" + invocationsIndName[functionId];
        var cacheIndex = _shadowStackHead ? _shadowStackHead : null;
        if (!cacheIndex || nonCacheableNodes[cacheIndex] || pageLoaded)
            return IBF;

        // if ((IBFStrDecl != null && IBFStrDecl.indexOf("createElement")>=0 )){
        //     nonCacheableNodes[cacheIndex] = "DOM element being created";
        //     return IBF;
        // }
        /*
        Commented the bottom part, because all the arguments are being statically handled
        However moving forward, we need to dynamically handle these, as static analysis
        doesn't completely create everything we need.
        */
        var stringificationErr = false;
        // argVals.forEach((arg,i)=>{
        //     var _argStr = omniStringifier.stringify(arg,"write",2);
        //     if (_argStr && _argStr instanceof Error){
        //         nonCacheableNodes[cacheIndex] = _argStr.message;
        //         stringificationErr = true;
        //     }
        //     if (typeof _argStr == "object") {
        //         val = _argStr[0];
        //     } else val  = " omniStringifier.parse(\"" + escapeRegExp(_argStr) + "\");\n";

        //     if (typeof arg == "string" && (arg.indexOf("arg[")>=0 || arg.indexOf("closure.")>=0))
        //         ibfStr += argStrs[i] + " = " + arg + ";\n"
        //     else ibfStr +=  argStrs[i]+ ' = ' + val + ";\n";
        // })
        // if (stringificationErr)
        //     return IBF;

        // ibfStr += IBFStrCall;
        if (customLocalStorage[cacheIndex]["IBF"] == null)
            customLocalStorage[cacheIndex]["IBF"] = ""
        customLocalStorage[cacheIndex]["IBF"] += "\n" + ibfStr + "\n";

        return IBF;
    }

    this.createArgumentProxy = function(argObj){
        if (pageLoaded || _shadowStackHead in nonCacheableNodes) return argObj;
        var nodeId = _shadowStackHead ? _shadowStackHead : null;
        if (!nodeId) return argObj;
        if (!argObj.length) return argObj;
        if (argObj.__isProxy) argObj = argObj.__target;
        var proxyHandler = proxyEncapsulation(argObj,"argument");
        var argProxy = new Proxy(argObj, proxyHandler);
        // proxyHandler.accessToPrivates().proxyToMethod.set(argProxy, argObj);
        if (invocationToArgProxy[nodeId]) console.error("invocation already has a previous proxy");
        invocationToArgProxy[nodeId] = proxyHandler;
        return argProxy
    }

    this.createClosureProxy = function(closureObj, scopeId){
        if (pageLoaded || _shadowStackHead in nonCacheableNodes) return closureObj;
        var nodeId = _shadowStackHead ? _shadowStackHead : null;
        if (!nodeId ) return closureObj;
        if (!Object.keys(closureObj).length) return closureObj;
        if (closureObj.__isProxy) closureObj = closureObj.__target;
        var proxyHandler;
        if (!(nodeId in functionToScopes))
            functionToScopes[nodeId] = [];
        if (functionToScopes[nodeId].indexOf(scopeId)<0)
            functionToScopes[nodeId].push(scopeId);
        if (scopeId in invocationToClosureProxy)
            proxyHandler = invocationToClosureProxy[scopeId];
        else {
            proxyHandler = proxyEncapsulation(closureObj,"closure", scopeId);
            invocationToClosureProxy[scopeId] = proxyHandler;
        }
        var closureProxy = new Proxy(closureObj, proxyHandler);
        // proxyHandler.accessToPrivates().proxyToMethod.set(closureProxy, closureObj);
        return closureProxy;
    }

    /*
    thisProxy is separate from argument Proxy, as the target object itself could
    be a proxy object, and we don't want to wrap a proxy on top a proxy
    therefore, first we check if it already is a proxy and get rid of it, before wrapping
    it up in a proxy.
    */
    this.createThisProxy = function(thisObj){
        if (pageLoaded || !thisObj || (typeof thisObj != "function" && typeof thisObj != "object")
         || _shadowStackHead in nonCacheableNodes ) return thisObj;
        if (thisObj.withCredentials != null) {
            nonCacheableNodes[_shadowStackHead] = "This: XMLHttpRequest"
            return thisObj;
        }
        var nodeId = _shadowStackHead ? _shadowStackHead : null;
        if (!nodeId) return thisObj;
        if (thisObj.__isProxy || thisObj == window) {
            handlePropagatedProxy(thisObj, null, "this",_shadowStackHead)
            thisObj = thisObj.__target != null ? thisObj.__target : window
        }
        var proxyHandler = proxyEncapsulation(thisObj,"this");
        var thisProxy = new Proxy(thisObj, proxyHandler);
        // proxyHandler.accessToPrivates().proxyToMethod.set(thisProxy, thisObj);
        if (invocationToThisProxy[nodeId]) console.error("invocation already has a previous proxy");
        invocationToThisProxy[nodeId] =   proxyHandler;
        return thisProxy;
    }

    var escapeRegExp = function(str) {
        return str.replace(/[\"]/g, "\\$&");
    }

    function isNative(fn) {
        return (/\{\s*\[native code\]\s*\}/).test('' + fn);
    }

    function stringify(obj) {
        try {
            return JSON.stringify(obj, function (key, value) {
              if (value && value.__isProxy)
                    value = value.__target;
              var fnBody;
              if (value instanceof Function || typeof value == 'function') {
                return "";
                if ((/\{\s*\[native code\]\s*\}/).test(value.toString())) {
                    return value.name;
                }
                fnBody = value.toString();

                if (fnBody.length < 8 || fnBody.substring(0, 8) !== 'function') { /*this is ES6 Arrow Function*/
                  return '_NuFrRa_' + fnBody;
                }
                return fnBody;
              }
              if (value instanceof RegExp) {
                return '_PxEgEr_' + value;
              }
              return value;
            });
        } catch(e){
            return e;
        }
    };

    function parse(str, date2obj) {

    var iso8061 = date2obj ? /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/ : false;

    return JSON.parse(str, function (key, value) {
        var prefix;

        if (typeof value != 'string') {
        return value;
        }
        if (value.length < 8) {
        return value;
        }

        prefix = value.substring(0, 8);

        if (iso8061 && value.match(iso8061)) {
            return new Date(value);
        }
        if (prefix === 'function') {
            // if ((/\{\s*\[native code\]\s*\}/).test(value))
            //     return nativeObjectsStore[key]
            return eval('(' + value + ')');
        }
        if (prefix === '_PxEgEr_') {
            return eval(value.slice(8));
        }
        if (prefix === '_NuFrRa_') {
            return eval(value.slice(8));
        }

        return value;
        });
    };

    class SignatureProcessor{

            //ptype - specifies the type of processing to do, by pointing to the node
            ///TODO
            // Clean the logic with objecttopathPerOT , since we aren't keeping it per ot
            constructor(signature, ObjectTree, callGraph, pType){
                this.signature = signature;
                this.objectTree = ObjectTree;
                this.processedSig = {};
                this.objectToPathPerOT = {"this":{}};
                this.callGraph = callGraph;
                this.logType = pType;
                this.pathDelim = ";;;;";
            }

            process(){
                var objectToPathPerOT = this.objectToPathPerOT;
                var objectTreeThis = this.objectTree;
                var signature = this.signature;
                var processedSig = this.processedSig;
                var reverseObjectToId = {};
                var logType = this.logType;
                var callGraph = this.callGraph;
                var pathDelim = this.pathDelim;

                var init = function(){
                    // switch(logType){
                    //     case  "global" :
                    //         objectToPathPerOT.this[0] = "window";
                    //         break;
                    //     case "argument" :
                    //         objectToPathPerOT.this[0] = "arg"
                    //         break;
                    //     case "closure":
                    //         objectToPathPerOT.this[0] = "closure"
                    //         break;
                    //     case "this" :
                    //         objectToPathPerOT.this[0] = "thisObj";
                    //         break;
                    // }
                    objectToPathPerOT.this[0] = "";
                }

                var stringify = function (obj) {

                    return JSON.stringify(obj, function (key, value) {
                      if (value.__isProxy)
                        value = value.__target;
                      var fnBody;
                      if (value instanceof Function || typeof value == 'function') {
                        return "";
                      //   return value.toString();

                      //   if ((/\{\s*\[native code\]\s*\}/).test(value.toString())) {
                      //       return {};
                      //   }
                      //   fnBody = value.toString();

                      //   if (fnBody.length < 8 || fnBody.substring(0, 8) !== 'function') { //this is ES6 Arrow Function
                      //     return '_NuFrRa_' + fnBody;
                      //   }
                      //   return fnBody;
                      // }
                      // if (value instanceof RegExp) {
                      //   return '_PxEgEr_' + value;
                      }
                      return value;
                    });
                };

                var _removeRedundantReads = function(nodeId, writeArray){
                    var readLength = signature[nodeId].reads.length;
                    if (readLength) {
                        while (readLength--){
                            if ( signature[nodeId].reads[readLength][0] == writeArray[0] && signature[nodeId].reads[readLength][1] == writeArray[1] )
                                signature[nodeId].reads.splice(readLength, 1);
                        }
                    }
                }
                var removeReduntantReads = function(){
                    for (var nodeId in signature){
                        if (signature[nodeId].writes.length) {
                            signature[nodeId].writes.forEach(function(write){
                                _removeRedundantReads(nodeId, write);
                            })
                        }
                    }
                }

                /*
                While constructing paths instead of using the dot operator for properties
                we use the bracket operators for two reasons
                - If the property is a number
                - if the property has special symbols like dot itlelf or spaces
                */

                var constructPath = function(objectId, OT="this"){
                    if (!objectToPathPerOT[OT]) objectToPathPerOT[OT] = {0:"arguments"};
                    if (objectToPathPerOT[OT][objectId] == "" || objectToPathPerOT[OT][objectId]) return objectToPathPerOT[OT][objectId];
                    var path = "";
                    var objectTree = OT == "this" ? objectTreeThis : invocationToArgProxy[OT].accessToPrivates().ObjectTree;
                    for (var nodeId in objectTree){
                        for (var edge in objectTree[nodeId]) {
                            var _id = objectTree[nodeId][edge].indexOf(parseInt(objectId));
                            if (_id>=0) {
                                var parentPath = constructPath(nodeId, OT);
                                // path = parentPath + "['" + edge.substr(2) + "']";
                                path = parentPath + pathDelim + edge.substr(2);
                                objectToPathPerOT[OT][objectId] = path;
                                return path;
                            }
                        }
                    }
                    console.error("NO PATH FOUND FOR OBJECT ID: " + objectId);
                }

                var reverseLookup = function(objectId) {
                    if (reverseObjectToId[objectId]) return reverseObjectToId[objectId];

                }

                var preProcess = function(OT){
                    var objectTree = OT == "this" ? objectTreeThis : invocationToArgProxy[OT].accessToPrivates().ObjectTree;
                    for (var nodeId in objectTree) {
                        var parentPath = constructPath(nodeId, OT);
                        if (!parentPath && parentPath != "") console.error("NO PARENT PATH FOUND WHILE PREPROCESSING " + nodeId );
                        for (var edge in objectTree[nodeId]) {
                            objectTree[nodeId][edge].forEach(function(objectId){
                                 if (!objectToPathPerOT.this[objectId]) {
                                    // var path = parentPath + "['" + edge.substr(2) + "']";
                                    var path = parentPath + pathDelim + edge.substr(2);
                                    objectToPathPerOT.this[objectId] = path;
                                }
                            })
                        }
                    }
                }

                var fetchValue = function(log){
                    var _id = parseInt(log);
                    if (!isNaN(_id))
                        return idToObject.get(_id);
                    else
                        return log.substr(2);
                }

                var getRootIds = function(readArr){
                    var ids = [];
                    readArr.forEach((read)=>{
                        ids.push(read[1]);
                    })
                    return [...new Set(ids)];
                }

                var getAllChildren = function(rootId,key){
                    var objectTreeNode = objectTreeThis[rootId];
                    if (!objectTreeNode) return [];

                    var children = objectTreeNode['e_' + key];
                    // FIX
                    /*all future reads from this object should be removed*/
                    return children || [];
                    return [];
                }

                var process = function(nodeId){
                    var arr = signature[nodeId], roots = [];
                    var writeObjs = {}, prunedInds = [], readsSeen = [],
                        writeObjsCh = [], readObjs = {};
                    arr.forEach(function(entry,ind){
                        //skip child placeholders
                        if (typeof entry == "string") return;
                        var type = entry[0];
                        if (type.indexOf(logType)<0) return;
                        var isWrite = type.indexOf("_reads")<0
                        var state = isWrite ? "write" : "read";
                        if (isWrite){
                            if (!writeObjs[entry[1]]){
                                writeObjs[entry[1]] = [];
                            }
                            writeObjs[entry[1]].push(entry[2]);
                            writeObjsCh = writeObjsCh.concat(getAllChildren(entry[1],entry[2]));
                        }
                        else if (writeObjs[entry[1]] && (writeObjs[entry[1]].indexOf(entry[2])>=0)
                            || writeObjsCh.indexOf(entry[1])>=0) {
                            prunedInds.push(ind);
                            return;
                        }
                        var sig = [type];
                        var OT = "this"
                        if (OT != "this")
                            preProcess(OT);
                        var parentPath = objectToPathPerOT[OT][entry[1]]
                        if (!parentPath && parentPath != "") console.log("no parent path found for object id:" + JSON.stringify(entry) + " " + nodeId);
                        try {
                            var str;
                            if (typeof entry[2] == 'symbol')
                                str = entry[2].toString()
                            else str = entry[2] + '';
                            var path = parentPath + pathDelim + str;
                            var val = entry[3];
                            // if (state == "write")
                            //     val = omniStringifier.stringify(val, state, 2);
                            sig[1] = path;
                            sig[2] = val;

                            //Special case while reading window
                            if (entry[4] === 0 && !isWrite) {
                                sig[1] += pathDelim + "self";
                                sig[2] = path;
                            }
                        } catch (e) {
                            //TODO
                            //suppressing for now
                            //SUPPRESS
                            throw e;
                            console.log("Error while trying to stringify path: " + e + e.stack);
                        }
                        if (sig) {
                            if (sig[0].indexOf("reads")>=0){
                                if (readsSeen.indexOf(sig[1])>=0)
                                    prunedInds.push(ind);
                                else readsSeen.push(sig[1]);
                            }
                            // if (detectProperty(readVal)) processedSig[nodeId].isFunction = true;
                            processedSig[nodeId][ind] = sig;
                        }
                    })
                    for (var i=prunedInds.length - 1;i>=0;i--)
                        processedSig[nodeId].splice(prunedInds[i],1);
                }

                var processWrite = function(nodeId){
                    var writeArray = signature[nodeId].filter(e=>e[0]==logType+"_writes");
                    writeArray.forEach(function(write){
                        var writeSignature = [logType+"_writes"];
                        var OT = "this"
                        if (OT != "this")
                            preProcess(OT);
                        var parentPath = objectToPathPerOT[OT][write[1]];
                        if (!parentPath && parentPath != "") console.log("no parent path found for object id:" + JSON.stringify(write) + " " + nodeId);
                        if (typeof write[2] == "symbol")
                            var path = parentPath + pathDelim + write[2].toString();
                        else var path = parentPath + pathDelim + write[2];
                        try {
                            var writeVal = write[3];
                            // writeSignature = path + " = omniStringifier.parse(`" + escapeRegExp(writeVal) +"`)";
                            writeSignature[1] = path;
                            writeSignature[2] = writeVal;
                        } catch (e) {
                            //TODO
                            //suppressing for now
                            //SUPPRESS
                            console.log("Error while stringifying path: " + e + e.stack);
                        }
                        if (writeSignature) {
                            // if (detectProperty(writeVal)) processedSig[nodeId].isFunction = true;
                            processedSig[nodeId].push(writeSignature);
                        }
                    })

                }

                //Generic function to detect a specific property of the signature
                var detectProperty = function(obj, property="function"){
                    if (typeof obj == "string")
                        return obj.split(';;').indexOf(property) >=0;
                    else if (typeof obj == property) return true;
                    else return false;
                }

                init();
                preProcess("this");
                //cleanup signatures ie remove a read after write
                // removeReduntantReads();

                Object.keys(this.signature).forEach(function(nodeId){
                    // Return if not leaf node
                    if (trackOnlyLeaf &&  callGraph[nodeId].length) {
                        // processedSig[nodeId] = "NonLeafNode";
                        return;
                    }
                    if (nodeId in nonCacheableNodes) return;
                    processedSig[nodeId] = signature[nodeId];
                    if (signature[nodeId].length)
                        process(nodeId)

                    //Remove redundant reads, ie reads with same keys

                    if (logType == "global"){
                        if (signature[nodeId].returnValue !== undefined) {
                            // var _ret = omniStringifier.stringify(signature[nodeId].returnValue,"write",2);
                            var _ret = signature[nodeId].returnValue
                            if (!(_ret instanceof Error)) {
                                processedSig[nodeId].push(['returnValue',_ret]);
                                // processedSig[nodeId].returnValue = _ret;
                            }
                            else delete processedSig[nodeId];

                        }
                        /***** HORCRUX *****/
                        signature[nodeId] &&  signature[nodeId].DOM_read && processedSig[nodeId] &&
                        (processedSig[nodeId].push(['DOM_read', signature[nodeId].DOM_read]));

                        signature[nodeId] &&  signature[nodeId].DOM_write && processedSig[nodeId] &&
                        (processedSig[nodeId].push(['DOM_write', signature[nodeId].DOM_write]));

                        signature[nodeId] &&  signature[nodeId].IBF && processedSig[nodeId] && (
                            processedSig[nodeId].push(['IBF',signature[nodeId].IBF]));

                        signature[nodeId] &&  signature[nodeId].ec && processedSig[nodeId] && (
                            processedSig[nodeId].push(['ec', signature[nodeId].ec]));

                        signature[nodeId] &&  signature[nodeId].CFG && processedSig[nodeId] && (
                            processedSig[nodeId].push(['CFG', signature[nodeId].CFG]));
                        // signature[nodeId] &&  signature[nodeId].startTime && processedSig[nodeId] && (
                        //     processedSig[nodeId].push(['startTime', signature[nodeId].startTime]));
                        // signature[nodeId] &&  signature[nodeId].endTime && processedSig[nodeId] && (
                        //     processedSig[nodeId].push(['endTime', signature[nodeId].endTime]));
                    }

                    // Object.keys(signature[nodeId]).forEach((key)=>{
                    //     if (!processedSig[nodeId][key]) {
                    //         // if (detectProperty(signature[nodeId][key])) processedSig[nodeId].isFunction = true;
                    //         processedSig[nodeId][key] = signature[nodeId][key];
                    //     }
                    // })
                });

            }

            postProcess() {
                var processedSig = this.processedSig;
                var callGraph = this.callGraph;
                var logType = this.logType;
                var _removeRedundantReads = function(keyArray){
                    var redundantIndices = [];
                    keyArray.forEach(key => {
                        var indices = keyArray.keys();
                        for (var i of indices) {
                            if (key.trim().indexOf(keyArray[i].trim()) >= 0 && keyArray[i].trim() != key.trim())
                                redundantIndices.push(i);
                        }
                    });

                    return [...(new Set(redundantIndices))]
                }

                var removeReduntantReads = function(nodeId){
                    var readArray = processedSig[nodeId][logType+"_reads"];
                    var keys = readArray.map(key => key.split('=')[0].trim());
                    var redundantIndices = _removeRedundantReads(keys);
                    for (var index = redundantIndices.length-1; index >= 0; index--)
                        readArray.splice(redundantIndices[index],1);
                    // redundantIndices.forEach(index => {
                    //     readArray.splice(index, 1);
                    // });
                }

                var removeReduntantReadsSimple = function(nodeId){
                    var readArray = processedSig[nodeId][logType+"_reads"];
                    processedSig[nodeId][logType+"_reads"] = [...new Set(readArray.map(e=>JSON.stringify(e)))].map(e=>JSON.parse(e));
                }

                Object.keys(processedSig).forEach(function(nodeId){
                    if (trackOnlyLeaf && callGraph[nodeId].length) return;
                    if (processedSig[nodeId][logType+"_reads"])
                        removeReduntantReadsSimple(nodeId);
                    // var readArray = processedSig[nodeId].reads;
                    // if (readArray && readArray.length) {
                    //     readArray = new Set(readArray);
                    //     processedSig[nodeId].reads = readArray;
                    // }
                    // var writeArray = processedSig[nodeId].writes;
                    // if (writeArray && writeArray.length) {
                    //     writeArray = new Set(writeArray);
                    //     processedSig[nodeId].writes = writeArray;
                    // }

                });
            }

            setPropagationData(pmd, proxyData, processedSig, nonCacheableNodes){
                this.PMD = pmd;
                this.proxyData = proxyData;
                this.processedSig = processedSig
                this.nonCacheableNodes = nonCacheableNodes;
            }
            /*
            Pseudo code
            - Traverse bottom up, for
            */
            signaturePropagate() {
                //Copy the call graph since we will be mutating it
                var callGraph = Object.assign({},this.callGraph);
                var processedSig = this.processedSig;
                var logType = this.logType;
                var pmd = this.PMD;
                var proxyData = this.proxyData;
                var nonCacheableNodes = this.nonCacheableNodes;

                var object2pathmem;
                var _getPathFromId = function(objectId, objectTree){
                    if (object2pathmem[objectId] != null) return object2pathmem[objectId];
                    for (var nodeId in objectTree){
                        for (var edge in objectTree[nodeId]) {
                            var _id = objectTree[nodeId][edge].indexOf(parseInt(objectId));
                            if (_id>=0) {
                                var parentPath = _getPathFromId(nodeId, objectTree);
                                // path = parentPath + "['" + edge.substr(2) + "']";
                                var path = parentPath + ";;;;" + edge.substr(2);
                                object2pathmem[objectId] = path;
                                return path;
                            }
                        }
                    }
                }

                var getPathFromId = function(objectId, functionId, stateType){
                    var proxyMap, newPath;
                    switch (stateType) {
                        case "argument" :
                            proxyMap = proxyData.i2a; break;
                        case "global" :
                            proxyMap = proxyData.gph; break;
                        case "this" :
                            proxyMap = proxyData.i2t; break;
                        case "closure":
                            proxyMap = proxyData.i2c; break;
                    }
                    var _proxyPrivates = (stateType == "global" ? globalProxyHandler : proxyMap[functionId])
                    if (!_proxyPrivates)
                        return new Error("Path not found while translating signature")
                    var proxyPrivates = _proxyPrivates.accessToPrivates();
                    object2pathmem = {0:""};
                    newPath = _getPathFromId(objectId, proxyPrivates.ObjectTree);
                    if (newPath == null){
                        return new Error("Path not found while translating signature")
                    }
                    return newPath
                }


                var translateSigInParentScope = function(parentNode, childNode, sigEntry, sigType){
                    var metadata = pmd[childNode];
                    var sigCat = sigEntry[0].split("_")[1];
                    if (sigType == "global" || sigType == "IBF") return Object.assign([],sigEntry);
                    if (!metadata[sigType] || !metadata[sigType].length)
                        return null;
                    var translatedEntry = [];
                    if (sigType == "argument") {
                        var mainArg = sigEntry[1].split(';;;;')[1];
                        var _matchMD = metadata[sigType].find(e=>e[0]==mainArg)
                        if (!_matchMD) return null;
                    } else
                        var _matchMD = metadata[sigType][0]
                    var newPath = getPathFromId(_matchMD[1],parentNode, _matchMD[2])
                    if (newPath && newPath.stack)
                        return newPath;
                    var newArg = _matchMD[2] + "_" + sigCat,
                        newKey = sigType == "argument" ? [newPath].concat(sigEntry[1].split(';;;;').slice(2,)).join(";;;;") :
                            newPath + sigEntry[1]
                    return [newArg, newKey, sigEntry[2]];
                }

                var rewriteKey = function(translatedSig, origSig, alreadyChildClosure){
                    var newKey = translatedSig[1].replace(origSig[1],"");
                    if (!alreadyChildClosure)
                        newKey = translatedSig[0].split("_")[0]  +  newKey   + ";&;" + origSig[1];
                    else newKey = translatedSig[0].split("_")[0]  +  newKey
                    return newKey;
                }

                //sigType = read or write
                var insertClosureSig = function(parentSig, insertInd, translatedSig, sigType, origSig, alreadyChildClosure){
                    var newSigType = sigType == "reads" ? "childClosure_reads" :
                        sigType == "IBF" ? "childIBF" : "childClosure_writes";
                    var newKey = rewriteKey(translatedSig, origSig,alreadyChildClosure);
                    var finalSig = [newSigType,newKey,translatedSig[2]];
                    parentSig.splice(insertInd,0,finalSig);
                }


                var _propagateHelper = function(sigEntry, parentNode, insertInd, childNode){
                    var sigType = sigEntry[0].split("_")[0],
                        parentSig = processedSig[parentNode];
                    switch(sigType){
                        case "global": parentSig.splice(insertInd, 0, sigEntry); break;
                        case "argument":
                        case "this":
                        case "closure":
                        case "IBF":
                            /*Handling IBF propagation similar to closure propagation*/
                            if (sigType == "IBF")
                                var translatedSig = translateSigInParentScope(parentNode, childNode, sigEntry, "closure")
                            else var translatedSig = translateSigInParentScope(parentNode, childNode, sigEntry, sigType)
                            if (translatedSig && !translatedSig.stack){
                                if (sigType == "closure"){
                                    insertClosureSig(parentSig, insertInd, translatedSig, sigEntry[0].split("_")[1], sigEntry)
                                    break;
                                } else if (sigType == "IBF"){
                                    insertClosureSig(parentSig, insertInd, translatedSig, "IBF", sigEntry)
                                    break;
                                }
                                parentSig.splice(insertInd, 0, translatedSig);
                            } else if (translatedSig && translatedSig.stack)
                                nonCacheableNodes[parentNode] = "translatedSig.message"
                            break;
                        case "childClosure":
                        case "childIBF":
                            var [childRef, actualKey] = sigEntry[1].split(';&;');
                            var dummySigType = childRef.split(';;;;')[0]+"_"+sigEntry[0].split("_")[1];
                            /*
                            if child accessed it through closure, simply append the key
                            however if the child accessed it through arguments or global, translate it accordingly
                            */
                            var childAccessor = "closure";
                            if (dummySigType.indexOf("argument")>=0 || dummySigType.indexOf("global")>=0){
                                childAccessor = "argument";
                                var dummySigEntry = [dummySigType, childRef.replace(childRef.split(';;;;')[0],""), sigEntry[2]];
                            }
                            else
                                var dummySigEntry = [dummySigType, "", sigEntry[2]];
                            var translatedSig = translateSigInParentScope(parentNode, childNode, dummySigEntry, childRef.split(';;;;')[0])
                            if (translatedSig && !translatedSig.stack){
                                    //fix the original reference part and the key part
                                    // translatedSig[1] = rewriteKey(translatedSig, dummySigEntry);
                                    //mimic the closure category, modify the key to include actualKey, without the state part
                                    if (childAccessor == "closure")
                                        translatedSig[1] += ';&;' + sigEntry[1];
                                    else dummySigEntry[1] = actualKey;
                                    //tweak the originalSig to simply reuse the insertClosureSig function
                                    // dummySigEntry[1]= actua.lKey
                                    var rwType = sigEntry[0].split("_")[1];
                                    if (sigType == "childIBF")
                                        rwType = "IBF"

                                    if (childAccessor == "closure")
                                        insertClosureSig(parentSig, insertInd, translatedSig, rwType, dummySigEntry, true)
                                    else
                                        insertClosureSig(parentSig, insertInd, translatedSig, rwType, dummySigEntry)
                            }

                    }
                }

                var propagateSig = function(parentNode, childNode){
                    var parentSig = processedSig[parentNode],
                        childSig = processedSig[childNode];
                    if (!parentSig || !childSig) return;
                    var phInd = parentSig.findIndex(e=>e==childNode),
                        cpPhInd = phInd;

                    if (phInd<0){
                        console.error("Parent node: " + parentNode + " has no placeholder for " + childNode );
                        return;
                    }
                    //Make space to insert childsig into parent sig
                    parentSig.splice(phInd,1)
                    childSig.forEach((sigEntry)=>{
                        var inserted = _propagateHelper(sigEntry,parentNode, phInd, childNode);
                        if (inserted)
                            phInd++
                    })
                    if (childSig.IBF){
                        var sigEntry = ["IBF", "", childSig.IBF]
                        var inserted = _propagateHelper(sigEntry,parentNode, phInd, childNode);
                        if (inserted)
                            phInd++
                    }
                    //Run optimizer after updating parent sig
                    // RWOpt(parentSig, cpPhInd);
                }

                var RWOpt = function(parentSig){
                    var cat2w = {}, //category to write
                        prunedInds = [],
                        readsSeen = {};
                    parentSig.forEach((entry,indx)=>{
                        var state = entry[0].split("_")[0];
                        if (!readsSeen[state])
                            readsSeen[state] = []
                        if (entry[0].indexOf("writes")>=0 ){
                            readsSeen[state].push(entry[1])
                            if (!cat2w[state])
                                cat2w[state] = [];
                            cat2w[state].push([entry[1],indx]) // state -> [key written to, index of the signature]
                        } else {
                            if (readsSeen[state].indexOf(entry[1])>=0 && prunedInds.indexOf(indx)<0)
                                prunedInds.push(indx)
                            else readsSeen[state].push(entry[1]);
                        }
                    })

                    parentSig.forEach((entry, indx)=>{
                            if (entry[0].indexOf("reads")>=0) {
                                var state = entry[0].split("_")[0];
                                if (!(state in cat2w)) return;
                                for (var write of cat2w[state]) {
                                    if (write[1] < indx && write[0].indexOf(entry[1])>=0 && prunedInds.indexOf(indx) < 0) {
                                        prunedInds.push(indx)
                                        break
                                    }
                                }
                            }
                    })
                    // Removing all the reads after writes
                    prunedInds = prunedInds.sort((b,a)=>{return b-a})
                    for (var i=prunedInds.length - 1;i>=0;i--)
                        parentSig.splice(prunedInds[i],1);

                }

                var updatedNodes = [];
                var visitChildren = function(parentNode){
                    if (updatedNodes.indexOf(parentNode)>=0) return;
                    var children = callGraph[parentNode];

                    for (var child of children){
                        visitChildren(child);
                        // console.log("Propagating " + child + " signature to " + parentNode)
                        if (child in nonCacheableNodes){
                            var childReason = nonCacheableNodes[child],
                                parentReason = "";
                            if (childReason.indexOf(";;")>=0){
                                parentReason = childReason;
                            } else {
                                parentReason += childReason + ";;parent-of-nc";
                            }
                            nonCacheableNodes[parentNode]=parentReason;
                            delete processedSig[parentNode]
                            updatedNodes.push(parentNode)
                            return;
                        }
                        propagateSig(parentNode,child);
                    }
                    updatedNodes.push(parentNode)
                }

                Object.keys(processedSig).forEach((parentNode)=>{
                    visitChildren(parentNode);
                })
                Object.keys(processedSig).forEach((parentNode)=>{
                    RWOpt(processedSig[parentNode]);
                })


            }
    }
    var setupStateEndTime = performance.now();
    window.top.setupStateTime[window.top.setupStateCounter++] = setupStateEndTime - setupStateStartTime;

    /*Set page loaded to true, since the initialization has happened
    and we need to turn off tracking for unnecessary functions*/
    // pageLoaded = false;
};

} /*else {
    __tracer = window.top.__tracer
}*/

/*if (typeof window === "undefined"){
    var globalProxyHandler = window.top.proxyEncapsulation(window,"global");

    var {proxy, revoke} = Proxy.revocable(window, globalProxyHandler);
    // Flag to disable proxy
    window = proxy;*
}*/

// (function () { __tracer.setGlobal(this); })();



</script>
<html lang="en"><body><script type="text/javascript">var td_0X=td_0X||{};td_0X.td_2L=function(td_I,td_t){try{var td_o=[""];var td_c=0;for(var td_W=0;td_W<td_t.length;++td_W){td_o.push(String.fromCharCode(td_I.charCodeAt(td_c)^td_t.charCodeAt(td_W)));td_c++;
if(td_c>=td_I.length){td_c=0;}}return td_o.join("");}catch(td_d){return null;}};td_0X.td_5l=function(td_w){if(!String||!String.fromCharCode||!parseInt){return null;}try{this.td_c=td_w;this.td_d="";this.td_f=function(td_x,td_t){if(0===this.td_d.length){var td_I=this.td_c.substr(0,32);
var td_c="";for(var td_b=32;td_b<td_w.length;td_b+=2){td_c+=String.fromCharCode(parseInt(td_w.substr(td_b,2),16));}this.td_d=td_0X.td_2L(td_I,td_c);}if(this.td_d.substr){return this.td_d.substr(td_x,td_t);
}};}catch(td_Y){}return null;};td_0X.td_1n=function(td_Z){if(td_Z===null||td_Z.length===null||!String||!String.fromCharCode){return null;}var td_y=null;try{var td_d="";var td_G=[];var td_g=String.fromCharCode(48)+String.fromCharCode(48)+String.fromCharCode(48);
var td_b=0;for(var td_n=0;td_n<td_Z.length;++td_n){if(65+td_b>=126){td_b=0;}var td_Y=(td_g+td_Z.charCodeAt(td_b++)).slice(-3);td_G.push(td_Y);}var td_D=td_G.join("");td_b=0;for(var td_n=0;td_n<td_D.length;
++td_n){if(65+td_b>=126){td_b=0;}var td_M=String.fromCharCode(65+td_b++);if(td_M!==[][[]]+""){td_d+=td_M;}}td_y=td_0X.td_2L(td_d,td_D);}catch(td_J){return null;}return td_y;};td_0X.td_4D=function(td_n){if(td_n===null||td_n.length===null){return null;
}var td_c="";try{var td_G="";var td_d=0;for(var td_Z=0;td_Z<td_n.length;++td_Z){if(65+td_d>=126){td_d=0;}var td_i=String.fromCharCode(65+td_d++);if(td_i!==[][[]]+""){td_G+=td_i;}}var td_A=td_0X.td_2L(td_G,td_n);
var td_j=td_A.match(/.{1,3}/g);for(var td_Z=0;td_Z<td_j.length;++td_Z){td_c+=String.fromCharCode(parseInt(td_j[td_Z],10));}}catch(td_p){return null;}return td_c;};td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97=new td_0X.td_5l("\x63\x39\x35\x62\x33\x31\x31\x35\x38\x64\x39\x65\x34\x65\x66\x61\x62\x38\x32\x63\x39\x65\x62\x34\x63\x35\x61\x39\x64\x65\x39\x37\x31\x30\x34\x64\x34\x37\x30\x62\x35\x64\x35\x36\x35\x37\x34\x30\x35\x36\x30\x37\x34\x64\x30\x63\x35\x62\x30\x62\x33\x64\x30\x65\x30\x30\x35\x32\x35\x37\x30\x30\x34\x64\x34\x35\x32\x33\x34\x36\x31\x31\x35\x34\x31\x38\x36\x34\x31\x31\x30\x62\x35\x32\x35\x39\x30\x63\x34\x65\x35\x62\x30\x31\x35\x63\x35\x63\x34\x31\x35\x39\x35\x64\x31\x30\x35\x63\x30\x61\x35\x61\x30\x39\x30\x39\x30\x30\x30\x36");
function td_a(td_f,td_b,td_F){if(typeof td_F===[][[]]+""||td_F===null){td_F=0;}else{if(td_F<0){td_F=Math.max(0,td_f.length+td_F);}}for(var td_V=td_F,td_Q=td_f.length;td_V<td_Q;td_V++){if(td_f[td_V]===td_b){return td_V;
}}return -1;}function td_l(td_z,td_Z,td_O){return td_z.indexOf(td_Z,td_O);}function td_G(td_U){if(typeof td_U!==((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(0,6)):null)||td_U===null||typeof td_U.replace===[][[]]+""||td_U.replace===null){return null;
}return td_U.replace(/^\s+|\s+$/g,"");}function td_J(td_n){if(typeof td_n!==((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(0,6)):null)||td_n===null||typeof td_n.trim===[][[]]+""||td_n.trim===null){return null;
}return td_n.trim();}function td_3z(td_X){if(typeof td_X!==((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(0,6)):null)||td_X===null||typeof td_X.trim===[][[]]+""||td_X.trim===null){return null;
}return td_X.trim();}function td_3g(td_m,td_A,td_d){return td_m.indexOf(td_A,td_d);}function td_i(){return Date.now();}function td_K(){return new Date().getTime();}function td_L(){return performance.now();
}function td_P(){return window.performance.now();}function td_3c(td_S){return parseFloat(td_S);}function td_1W(td_S){return parseInt(td_S);}function td_0s(td_A){return isNaN(td_A);}function td_2s(td_S){return isFinite(td_S);
}function td_t(){if(typeof Number.parseFloat!==[][[]]+""&&typeof Number.parseInt!==[][[]]+""){td_3c=Number.parseFloat;td_1W=Number.parseInt;}else{if(typeof parseFloat!==[][[]]+""&&typeof parseInt!==[][[]]+""){td_3c=parseFloat;
td_1W=parseInt;}else{td_3c=null;td_1W=null;}}if(typeof Number.isNaN!==[][[]]+""){td_0s=Number.isNaN;}else{if(typeof isNaN!==[][[]]+""){td_0s=isNaN;}else{td_0s=null;}}if(typeof Number.isFinite!==[][[]]+""){td_2s=Number.isFinite;
}else{if(typeof isFinite!==[][[]]+""){td_2s=isFinite;}else{td_2s=null;}}}function td_R(){if(!Array.prototype.indexOf){td_3g=td_a;}else{td_3g=td_l;}if(typeof String.prototype.trim!==((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(6,8)):null)){td_3z=td_G;
}else{td_3z=td_J;}if(typeof Date.now===[][[]]+""){td_i=td_K;}var td_O=false;if(typeof performance===[][[]]+""||typeof performance.now===[][[]]+""){if(typeof window.performance!==[][[]]+""&&typeof window.performance.now!==[][[]]+""){td_L=td_P;
}else{td_L=td_i;td_O=true;}}if(!td_O){var td_d=td_L();var td_f=td_d.toFixed();if(td_d===td_f){td_L=td_i;}}if(typeof Array.isArray===[][[]]+""){Array.isArray=function(td_E){return Object.prototype.toString.call(td_E)===((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(14,14)):null);
};}td_t();}function td_1E(td_X){if(typeof document.readyState!==[][[]]+""&&typeof document.readyState!==((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(28,7)):null)&&document.readyState===((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(35,8)):null)){td_X();
}else{if(typeof document.readyState===[][[]]+""){setTimeout(td_X,300);}else{var td_m=200;var td_f;if(typeof window!==[][[]]+""&&typeof window!==((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(28,7)):null)&&window!==null){td_f=window;
}else{td_f=document.body;}if(td_f.addEventListener){td_f.addEventListener(Number(343388).toString(25),function(){setTimeout(td_X,td_m);},false);}else{if(td_f.attachEvent){td_f.attachEvent(((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(43,6)):null),function(){setTimeout(td_X,td_m);
},false);}else{var td_b=td_f.onload;td_f.onload=new function(){var td_F=true;if(td_b!==null&&typeof td_b===((typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97)!=="undefined"&&typeof(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f)!=="undefined")?(td_0X.tdz_c95b31158d9e4efab82c9eb4c5a9de97.td_f(6,8)):null)){td_F=td_b();
}setTimeout(td_X,td_m);td_f.onload=td_b;return td_F;};}}}}}function td_c(){if(typeof td_4X!==[][[]]+""){td_4X();}if(typeof td_0F!==[][[]]+""){td_0F();}if(typeof td_1s!==[][[]]+""){td_1s();}if(typeof td_4r!==[][[]]+""){if(typeof td_4U!==[][[]]+""&&td_4U!==null){td_4r(td_4U,false);
}if(typeof td_5s!==[][[]]+""&&td_5s!==null){td_4r(td_5s,true);}}if(typeof tmx_link_scan!==[][[]]+""){tmx_link_scan();}if(typeof td_4f!==[][[]]+""){td_4f();}if(typeof td_5a!==[][[]]+""){td_5a.start();}if(typeof td_1l!==[][[]]+""){td_1l.start();
}}function td_3k(){try{td_0X.td_3U();td_0X.td_0T(document);td_5x.td_0f();td_R();td_1E(td_c);}catch(td_Z){}}td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157=new td_0X.td_5l("\x61\x37\x35\x32\x62\x35\x61\x37\x33\x33\x34\x62\x34\x63\x35\x62\x62\x35\x61\x37\x37\x62\x65\x32\x64\x61\x65\x64\x38\x31\x35\x37\x30\x39\x34\x33\x34\x31\x34\x32\x31\x31\x34\x31\x31\x31\x34\x34\x34\x37\x35\x32\x34\x36\x31\x36\x30\x39\x34\x35\x34\x31\x31\x32\x30\x37\x35\x62\x30\x35\x30\x61\x34\x33\x31\x32\x35\x38\x37\x35\x32\x31\x33\x35\x30\x37\x30\x31\x35\x65\x35\x65\x34\x37\x35\x32\x31\x34\x35\x39\x35\x39\x35\x64\x30\x33\x35\x31\x31\x34\x35\x39\x35\x66\x35\x63\x35\x35\x30\x36\x35\x62\x30\x64\x35\x37\x30\x37\x30\x34\x35\x61\x31\x33\x35\x32\x34\x32\x30\x63\x30\x39\x35\x64\x30\x35\x30\x35\x30\x61\x30\x61\x34\x64\x35\x66\x35\x39\x35\x38\x30\x30\x35\x33");
var td_0X=td_0X||{};if(typeof td_0X.td_5f===[][[]]+""){td_0X.td_5f=[];}var td_kO=false;var td_Xy=new Date().getTime();function td_dw(){if(document.all&&location.protocol.indexOf(((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(0,5)):null))===-1){return;
}if(td_kO){return;}td_kO=true;var td_pw="";var td_Bs=td_i();var td_Ek=td_Bs-td_Xy;if(td_Ek<0||td_Ek>3600000){td_pw+=((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(5,8)):null)+td_Xy+((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(13,7)):null)+td_Bs;
}else{td_pw+=((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(20,3)):null)+td_Ek;
}if(navigator&&navigator.sendBeacon){navigator.sendBeacon(td_1t,td_pw);}else{var td_xB=td_0X.td_2M();if(!td_xB){return;}try{td_xB.open(((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(23,3)):null),td_1t+"&"+td_pw,false);
td_xB.send(null);}catch(td_sK){}}}function td_oM(){if(typeof window.addEventListener!==[][[]]+""){window.addEventListener(((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(26,12)):null),td_dw,false);
window.addEventListener(((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(38,6)):null),td_dw,false);
}else{if(typeof window.attachEvent!==[][[]]+""){window.attachEvent(((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(44,14)):null),td_dw);
window.attachEvent(((typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157)!=="undefined"&&typeof(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f)!=="undefined")?(td_0X.tdz_a752b5a7334b4c5bb5a77be2daed8157.td_f(58,8)):null),td_dw);
}else{window.onbeforeunload=td_dw;window.onunload=td_dw;}}}function td_0k(){td_0X.td_3U();td_0X.td_0T(document);td_R();td_oM();}td_0X.td_5f.push(function(){var td_2Q= new td_0X.td_5l("ade5b509bfe44c959245e32a759e527109101145110F1F16061403505D104F561745555908524015195656081A44074011370C5D0E635753230F2F6C555C5A0D5853055404000B5252575B0656070A020B231C472362764E31083C077D08527640620551364579511A044B2B5366797E29140F62337A4041103F5603621351627A03635D2B704818685069377E02795A520F0C404F5C0572161704727F4E0B42587E5C0D57467B0E5D4F6B2C65797D7A16283F06045E037F0327147E7C0D004D691F626A550077187367725062755B61303D1D703A5E7B5A070B55416B575E7A51537D5C01515407706C");td_1t=(td_2Q)?td_2Q.td_f(0,218):null;});td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a=new td_0X.td_5l("\x65\x36\x39\x32\x39\x36\x37\x63\x31\x34\x35\x62\x34\x33\x65\x62\x39\x39\x35\x61\x62\x33\x34\x65\x31\x63\x64\x31\x61\x33\x32\x61\x30\x63\x35\x38\x34\x39\x34\x37\x34\x64\x31\x36\x35\x65\x31\x30\x31\x31\x35\x64\x35\x62\x31\x34\x35\x35\x35\x66\x30\x63\x30\x36\x31\x39\x34\x64\x34\x63\x31\x31\x30\x37\x35\x63\x35\x36\x30\x66\x35\x34\x30\x30\x31\x30\x30\x31\x35\x30\x30\x31\x30\x31\x35\x35\x35\x30\x30\x30\x30\x65\x30\x61\x30\x30\x35\x37\x35\x35\x30\x30\x35\x35\x35\x31\x35\x33\x33\x39\x35\x62\x35\x31\x30\x66\x30\x37\x35\x61\x34\x64\x31\x35\x32\x30\x31\x30\x34\x31\x35\x35\x31\x63\x36\x63\x31\x30\x31\x30\x34\x33\x30\x38\x35\x64\x35\x35");
td_2J=function(){var td_gu=((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(0,21)):null);
var td_Kj=typeof window===((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(21,6)):null);
var td_z6=td_Kj?window:{};if(td_z6.JS_SHA256_NO_WINDOW){td_Kj=false;}var td_Eq=!td_z6.JS_SHA256_NO_ARRAY_BUFFER&&typeof ArrayBuffer!==[][[]]+"";var td_T=((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(27,16)):null).split("");
var td_Wv=[-2147483648,8388608,32768,128];var td_Oy=[24,16,8,0];var td_YT=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298];
var td_z=[];if(td_z6.JS_SHA256_NO_NODE_JS||!Array.isArray){Array.isArray=function(td_Ra){return Object.prototype.toString.call(td_Ra)===((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(43,14)):null);
};}if(td_Eq&&(td_z6.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)){ArrayBuffer.isView=function(td_h6){return typeof td_h6===((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(21,6)):null)&&td_h6.buffer&&td_h6.buffer.constructor===ArrayBuffer;
};}instance=new td_wz(false,false);this.update=function(td_iq){instance.update(td_iq);};this.hash=function(td_k3){instance.update(td_k3);return instance.toString();};this.toString=function(){return instance.toString();
};function td_wz(){this.blocks=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];this.h0=1779033703;this.h1=3144134277;this.h2=1013904242;this.h3=2773480762;this.h4=1359893119;this.h5=2600822924;this.h6=528734635;this.h7=1541459225;
this.block=this.start=this.bytes=this.hBytes=0;this.finalized=this.hashed=false;this.first=true;}td_wz.prototype.update=function(td_uC){if(this.finalized){return;}var td_ii,td_in=typeof td_uC;if(td_in!==((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(57,6)):null)){if(td_in===((typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a)!=="undefined"&&typeof(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f)!=="undefined")?(td_0X.tdz_e692967c145b43eb995ab34e1cd1a32a.td_f(21,6)):null)){if(td_uC===null){throw new Error(td_gu);
}else{if(td_Eq&&td_uC.constructor===ArrayBuffer){td_uC=new Uint8Array(td_uC);}else{if(!Array.isArray(td_uC)){if(!td_Eq||!ArrayBuffer.isView(td_uC)){throw new Error(td_gu);}}}}}else{throw new Error(td_gu);
}td_ii=true;}var td_Jp,td_et=0,td_L9,td_RR=td_uC.length,td_IC=this.blocks;while(td_et<td_RR){if(this.hashed){this.hashed=false;td_IC[0]=this.block;td_IC[16]=td_IC[1]=td_IC[2]=td_IC[3]=td_IC[4]=td_IC[5]=td_IC[6]=td_IC[7]=td_IC[8]=td_IC[9]=td_IC[10]=td_IC[11]=td_IC[12]=td_IC[13]=td_IC[14]=td_IC[15]=0;
}if(td_ii){for(td_L9=this.start;td_et<td_RR&&td_L9<64;++td_et){td_IC[td_L9>>2]|=td_uC[td_et]<<td_Oy[td_L9++&3];}}else{for(td_L9=this.start;td_et<td_RR&&td_L9<64;++td_et){td_Jp=td_uC.charCodeAt(td_et);if(td_Jp<128){td_IC[td_L9>>2]|=td_Jp<<td_Oy[td_L9++&3];
}else{if(td_Jp<2048){td_IC[td_L9>>2]|=(192|(td_Jp>>6))<<td_Oy[td_L9++&3];td_IC[td_L9>>2]|=(128|(td_Jp&63))<<td_Oy[td_L9++&3];}else{if(td_Jp<55296||td_Jp>=57344){td_IC[td_L9>>2]|=(224|(td_Jp>>12))<<td_Oy[td_L9++&3];
td_IC[td_L9>>2]|=(128|((td_Jp>>6)&63))<<td_Oy[td_L9++&3];td_IC[td_L9>>2]|=(128|(td_Jp&63))<<td_Oy[td_L9++&3];}else{td_Jp=65536+(((td_Jp&1023)<<10)|(td_uC.charCodeAt(++td_et)&1023));td_IC[td_L9>>2]|=(240|(td_Jp>>18))<<td_Oy[td_L9++&3];
td_IC[td_L9>>2]|=(128|((td_Jp>>12)&63))<<td_Oy[td_L9++&3];td_IC[td_L9>>2]|=(128|((td_Jp>>6)&63))<<td_Oy[td_L9++&3];td_IC[td_L9>>2]|=(128|(td_Jp&63))<<td_Oy[td_L9++&3];}}}}}this.lastByteIndex=td_L9;this.bytes+=td_L9-this.start;
if(td_L9>=64){this.block=td_IC[16];this.start=td_L9-64;this.hash();this.hashed=true;}else{this.start=td_L9;}}if(this.bytes>4294967295){this.hBytes+=this.bytes/4294967296<<0;this.bytes=this.bytes%4294967296;
}return this;};td_wz.prototype.finalize=function(){if(this.finalized){return;}this.finalized=true;var td_Vu=this.blocks,td_e0=this.lastByteIndex;td_Vu[16]=this.block;td_Vu[td_e0>>2]|=td_Wv[td_e0&3];this.block=td_Vu[16];
if(td_e0>=56){if(!this.hashed){this.hash();}td_Vu[0]=this.block;td_Vu[16]=td_Vu[1]=td_Vu[2]=td_Vu[3]=td_Vu[4]=td_Vu[5]=td_Vu[6]=td_Vu[7]=td_Vu[8]=td_Vu[9]=td_Vu[10]=td_Vu[11]=td_Vu[12]=td_Vu[13]=td_Vu[14]=td_Vu[15]=0;
}td_Vu[14]=this.hBytes<<3|this.bytes>>>29;td_Vu[15]=this.bytes<<3;this.hash();};td_wz.prototype.hash=function(){var td_Xj=this.h0,td_o0=this.h1,td_EV=this.h2,td_dr=this.h3,td_ej=this.h4,td_BA=this.h5,td_mX=this.h6,td_vw=this.h7,td_KG=this.blocks,td_AV,td_WD,td_tD,td_Jc,td_Ze,td_mf,td_Ts,td_CW,td_LZ,td_q5,td_eE;
for(td_AV=16;td_AV<64;++td_AV){td_Ze=td_KG[td_AV-15];td_WD=((td_Ze>>>7)|(td_Ze<<25))^((td_Ze>>>18)|(td_Ze<<14))^(td_Ze>>>3);td_Ze=td_KG[td_AV-2];td_tD=((td_Ze>>>17)|(td_Ze<<15))^((td_Ze>>>19)|(td_Ze<<13))^(td_Ze>>>10);
td_KG[td_AV]=td_KG[td_AV-16]+td_WD+td_KG[td_AV-7]+td_tD<<0;}td_eE=td_o0&td_EV;for(td_AV=0;td_AV<64;td_AV+=4){if(this.first){td_CW=704751109;td_Ze=td_KG[0]-210244248;td_vw=td_Ze-1521486534<<0;td_dr=td_Ze+143694565<<0;
this.first=false;}else{td_WD=((td_Xj>>>2)|(td_Xj<<30))^((td_Xj>>>13)|(td_Xj<<19))^((td_Xj>>>22)|(td_Xj<<10));td_tD=((td_ej>>>6)|(td_ej<<26))^((td_ej>>>11)|(td_ej<<21))^((td_ej>>>25)|(td_ej<<7));td_CW=td_Xj&td_o0;
td_Jc=td_CW^(td_Xj&td_EV)^td_eE;td_Ts=(td_ej&td_BA)^(~td_ej&td_mX);td_Ze=td_vw+td_tD+td_Ts+td_YT[td_AV]+td_KG[td_AV];td_mf=td_WD+td_Jc;td_vw=td_dr+td_Ze<<0;td_dr=td_Ze+td_mf<<0;}td_WD=((td_dr>>>2)|(td_dr<<30))^((td_dr>>>13)|(td_dr<<19))^((td_dr>>>22)|(td_dr<<10));
td_tD=((td_vw>>>6)|(td_vw<<26))^((td_vw>>>11)|(td_vw<<21))^((td_vw>>>25)|(td_vw<<7));td_LZ=td_dr&td_Xj;td_Jc=td_LZ^(td_dr&td_o0)^td_CW;td_Ts=(td_vw&td_ej)^(~td_vw&td_BA);td_Ze=td_mX+td_tD+td_Ts+td_YT[td_AV+1]+td_KG[td_AV+1];
td_mf=td_WD+td_Jc;td_mX=td_EV+td_Ze<<0;td_EV=td_Ze+td_mf<<0;td_WD=((td_EV>>>2)|(td_EV<<30))^((td_EV>>>13)|(td_EV<<19))^((td_EV>>>22)|(td_EV<<10));td_tD=((td_mX>>>6)|(td_mX<<26))^((td_mX>>>11)|(td_mX<<21))^((td_mX>>>25)|(td_mX<<7));
td_q5=td_EV&td_dr;td_Jc=td_q5^(td_EV&td_Xj)^td_LZ;td_Ts=(td_mX&td_vw)^(~td_mX&td_ej);td_Ze=td_BA+td_tD+td_Ts+td_YT[td_AV+2]+td_KG[td_AV+2];td_mf=td_WD+td_Jc;td_BA=td_o0+td_Ze<<0;td_o0=td_Ze+td_mf<<0;td_WD=((td_o0>>>2)|(td_o0<<30))^((td_o0>>>13)|(td_o0<<19))^((td_o0>>>22)|(td_o0<<10));
td_tD=((td_BA>>>6)|(td_BA<<26))^((td_BA>>>11)|(td_BA<<21))^((td_BA>>>25)|(td_BA<<7));td_eE=td_o0&td_EV;td_Jc=td_eE^(td_o0&td_dr)^td_q5;td_Ts=(td_BA&td_mX)^(~td_BA&td_vw);td_Ze=td_ej+td_tD+td_Ts+td_YT[td_AV+3]+td_KG[td_AV+3];
td_mf=td_WD+td_Jc;td_ej=td_Xj+td_Ze<<0;td_Xj=td_Ze+td_mf<<0;}this.h0=this.h0+td_Xj<<0;this.h1=this.h1+td_o0<<0;this.h2=this.h2+td_EV<<0;this.h3=this.h3+td_dr<<0;this.h4=this.h4+td_ej<<0;this.h5=this.h5+td_BA<<0;
this.h6=this.h6+td_mX<<0;this.h7=this.h7+td_vw<<0;};td_wz.prototype.hex=function(){this.finalize();var td_FT=this.h0,td_wh=this.h1,td_hi=this.h2,td_wN=this.h3,td_Me=this.h4,td_t6=this.h5,td_s8=this.h6,td_Jf=this.h7;
var td_LH=td_T[(td_FT>>28)&15]+td_T[(td_FT>>24)&15]+td_T[(td_FT>>20)&15]+td_T[(td_FT>>16)&15]+td_T[(td_FT>>12)&15]+td_T[(td_FT>>8)&15]+td_T[(td_FT>>4)&15]+td_T[td_FT&15]+td_T[(td_wh>>28)&15]+td_T[(td_wh>>24)&15]+td_T[(td_wh>>20)&15]+td_T[(td_wh>>16)&15]+td_T[(td_wh>>12)&15]+td_T[(td_wh>>8)&15]+td_T[(td_wh>>4)&15]+td_T[td_wh&15]+td_T[(td_hi>>28)&15]+td_T[(td_hi>>24)&15]+td_T[(td_hi>>20)&15]+td_T[(td_hi>>16)&15]+td_T[(td_hi>>12)&15]+td_T[(td_hi>>8)&15]+td_T[(td_hi>>4)&15]+td_T[td_hi&15]+td_T[(td_wN>>28)&15]+td_T[(td_wN>>24)&15]+td_T[(td_wN>>20)&15]+td_T[(td_wN>>16)&15]+td_T[(td_wN>>12)&15]+td_T[(td_wN>>8)&15]+td_T[(td_wN>>4)&15]+td_T[td_wN&15]+td_T[(td_Me>>28)&15]+td_T[(td_Me>>24)&15]+td_T[(td_Me>>20)&15]+td_T[(td_Me>>16)&15]+td_T[(td_Me>>12)&15]+td_T[(td_Me>>8)&15]+td_T[(td_Me>>4)&15]+td_T[td_Me&15]+td_T[(td_t6>>28)&15]+td_T[(td_t6>>24)&15]+td_T[(td_t6>>20)&15]+td_T[(td_t6>>16)&15]+td_T[(td_t6>>12)&15]+td_T[(td_t6>>8)&15]+td_T[(td_t6>>4)&15]+td_T[td_t6&15]+td_T[(td_s8>>28)&15]+td_T[(td_s8>>24)&15]+td_T[(td_s8>>20)&15]+td_T[(td_s8>>16)&15]+td_T[(td_s8>>12)&15]+td_T[(td_s8>>8)&15]+td_T[(td_s8>>4)&15]+td_T[td_s8&15];
td_LH+=td_T[(td_Jf>>28)&15]+td_T[(td_Jf>>24)&15]+td_T[(td_Jf>>20)&15]+td_T[(td_Jf>>16)&15]+td_T[(td_Jf>>12)&15]+td_T[(td_Jf>>8)&15]+td_T[(td_Jf>>4)&15]+td_T[td_Jf&15];return td_LH;};td_wz.prototype.toString=td_wz.prototype.hex;
};var td_0X=td_0X||{};td_0X.td_2L=function(td_I,td_t){try{var td_o=[""];var td_c=0;for(var td_W=0;td_W<td_t.length;++td_W){td_o.push(String.fromCharCode(td_I.charCodeAt(td_c)^td_t.charCodeAt(td_W)));td_c++;
if(td_c>=td_I.length){td_c=0;}}return td_o.join("");}catch(td_d){return null;}};td_0X.td_5l=function(td_w){if(!String||!String.fromCharCode||!parseInt){return null;}try{this.td_c=td_w;this.td_d="";this.td_f=function(td_x,td_t){if(0===this.td_d.length){var td_I=this.td_c.substr(0,32);
var td_c="";for(var td_b=32;td_b<td_w.length;td_b+=2){td_c+=String.fromCharCode(parseInt(td_w.substr(td_b,2),16));}this.td_d=td_0X.td_2L(td_I,td_c);}if(this.td_d.substr){return this.td_d.substr(td_x,td_t);
}};}catch(td_Y){}return null;};td_0X.td_1n=function(td_Z){if(td_Z===null||td_Z.length===null||!String||!String.fromCharCode){return null;}var td_y=null;try{var td_d="";var td_G=[];var td_g=String.fromCharCode(48)+String.fromCharCode(48)+String.fromCharCode(48);
var td_b=0;for(var td_n=0;td_n<td_Z.length;++td_n){if(65+td_b>=126){td_b=0;}var td_Y=(td_g+td_Z.charCodeAt(td_b++)).slice(-3);td_G.push(td_Y);}var td_D=td_G.join("");td_b=0;for(var td_n=0;td_n<td_D.length;
++td_n){if(65+td_b>=126){td_b=0;}var td_M=String.fromCharCode(65+td_b++);if(td_M!==[][[]]+""){td_d+=td_M;}}td_y=td_0X.td_2L(td_d,td_D);}catch(td_J){return null;}return td_y;};td_0X.td_4D=function(td_n){if(td_n===null||td_n.length===null){return null;
}var td_c="";try{var td_G="";var td_d=0;for(var td_Z=0;td_Z<td_n.length;++td_Z){if(65+td_d>=126){td_d=0;}var td_i=String.fromCharCode(65+td_d++);if(td_i!==[][[]]+""){td_G+=td_i;}}var td_A=td_0X.td_2L(td_G,td_n);
var td_j=td_A.match(/.{1,3}/g);for(var td_Z=0;td_Z<td_j.length;++td_Z){td_c+=String.fromCharCode(parseInt(td_j[td_Z],10));}}catch(td_p){return null;}return td_c;};td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d=new td_0X.td_5l("\x64\x32\x37\x31\x38\x35\x66\x65\x66\x66\x65\x31\x34\x33\x63\x30\x38\x37\x62\x64\x34\x65\x30\x66\x61\x31\x37\x64\x34\x61\x37\x64\x35\x34\x30\x33\x30\x35\x30\x32\x30\x63\x30\x30\x35\x30\x35\x32\x35\x65\x35\x66\x30\x34\x35\x33\x35\x37\x35\x37\x30\x36\x35\x36\x35\x64\x35\x39\x32\x62\x32\x32\x36\x36\x32\x34\x37\x64\x32\x33\x30\x38\x35\x37\x34\x35\x30\x35\x35\x39\x30\x34\x35\x32\x30\x39\x31\x34\x34\x36\x34\x65\x35\x30\x34\x61\x35\x63\x30\x37\x34\x38\x30\x32\x30\x66\x31\x36\x35\x30\x35\x36\x35\x66\x30\x36\x35\x34\x35\x39\x34\x35\x30\x62\x30\x35\x31\x39\x30\x64\x35\x39\x30\x32\x30\x35\x35\x34\x35\x39\x34\x39\x30\x35\x31\x32\x35\x36\x30\x61\x30\x30\x35\x30\x35\x38\x34\x39\x35\x62\x35\x61\x30\x61\x30\x61\x31\x34\x35\x63\x31\x37\x35\x36\x35\x36\x35\x32\x34\x62\x30\x30\x31\x34\x30\x37\x34\x65\x35\x34\x31\x38\x35\x35\x31\x39\x35\x64\x34\x31\x35\x37\x35\x62\x30\x62\x35\x35\x31\x35\x30\x64\x30\x38\x30\x31\x35\x34\x34\x33\x30\x61\x31\x38\x34\x35\x30\x39\x31\x36\x30\x66\x31\x32\x30\x63\x35\x65\x35\x61\x30\x39\x30\x32\x35\x32\x34\x62\x35\x38\x30\x65\x31\x31\x34\x30\x30\x30\x30\x62\x34\x36\x31\x35\x35\x65\x34\x37\x35\x65\x31\x39\x35\x33\x30\x37\x35\x34\x35\x66\x31\x32\x35\x62\x35\x34\x35\x65\x34\x31\x35\x63\x34\x38\x35\x34\x35\x36\x35\x35\x30\x61\x31\x34\x35\x31\x30\x63\x34\x32\x35\x63\x35\x32\x31\x30\x35\x65\x30\x34\x31\x35\x34\x38\x31\x35\x31\x33\x35\x32\x35\x39\x30\x62\x35\x61\x30\x32\x35\x32\x32\x39\x33\x37\x36\x61\x37\x61\x37\x64\x30\x61\x31\x62\x33\x65\x32\x38\x32\x61\x32\x65\x33\x31\x36\x35\x36\x34\x31\x64\x35\x30\x31\x65\x30\x38\x37\x61\x31\x31\x31\x63\x35\x39\x30\x39\x30\x32\x34\x38\x33\x39\x37\x63\x37\x62\x32\x63\x36\x30\x33\x35\x36\x37\x32\x39\x30\x64\x35\x31\x34\x35\x35\x65\x34\x62\x35\x61\x30\x30\x31\x31\x34\x38\x33\x65\x32\x38\x37\x64\x37\x63\x36\x37\x33\x37\x36\x30");
var td_0X=td_0X||{};if(typeof td_0X.td_5f===[][[]]+""){td_0X.td_5f=[];}td_0X.td_3U=function(){for(var td_Q=0;td_Q<td_0X.td_5f.length;++td_Q){td_0X.td_5f[td_Q]();}};td_0X.td_5d=function(td_U,td_T){try{var td_d=td_U.length+"&"+td_U;
var td_X="";var td_S=((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(0,16)):null);
for(var td_A=0,td_F=0;td_A<td_d.length;td_A++){var td_n=td_d.charCodeAt(td_A)^td_T.charCodeAt(td_F)&10;if(++td_F===td_T.length){td_F=0;}td_X+=td_S.charAt((td_n>>4)&15);td_X+=td_S.charAt(td_n&15);}return td_X;
}catch(td_z){return null;}};td_0X.td_4n=function(){try{var td_X=window.top.document;var td_A=td_X.forms.length;return td_X;}catch(td_m){return document;}};td_0X.td_1L=function(td_O){try{var td_U;if(typeof td_O===[][[]]+""){td_U=window;
}else{if(td_O==="t"){td_U=window.top;}else{if(td_O==="p"){td_U=window.parent;}else{td_U=window;}}}var td_S=td_U.document.forms.length;return td_U;}catch(td_b){return window;}};td_0X.add_lang_attr_html_tag=function(td_S){try{if(td_S===null){return;
}var td_n=td_S.getElementsByTagName(Number(485781).toString(30));if(typeof td_n!==[][[]]+""&&td_n!==null&&typeof td_n.length!==[][[]]+""&&td_n.length!==null&&td_n.length>0&&typeof td_n[0]!==[][[]]+""&&typeof td_n[0]!==null&&typeof td_n[0].setAttribute!==[][[]]+""&&td_n[0].setAttribute!==null&&typeof td_n[0].getAttribute!==[][[]]+""&&td_n[0].getAttribute!==null&&(td_n[0].getAttribute(Number(296632).toString(24))===null||td_n[0].getAttribute(Number(296632).toString(24))==="")){td_n[0].setAttribute(Number(296632).toString(24),((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(16,2)):null));
}else{}}catch(td_A){}};td_0X.load_iframe=function(td_F,td_V){var td_T=td_1a(5);if(typeof(td_5i)!==[][[]]+""){td_5i(td_T,((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(18,6)):null));
}var td_m=td_V.createElement(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(24,6)):null));
td_m.id=td_T;td_m.title=((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(30,5)):null);
td_m.setAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(35,13)):null),Number(890830).toString(31));
td_m.setAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(48,11)):null),Number(890830).toString(31));
td_m.width="0";td_m.height="0";if(typeof td_m.tabIndex!==[][[]]+""){td_m.tabIndex=((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(59,2)):null);
}if(typeof td_5o!==[][[]]+""&&td_5o!==null){td_m.setAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(61,7)):null),td_5o);
}td_m.style=((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(68,83)):null);
td_m.setAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(151,3)):null),td_F);
td_V.body.appendChild(td_m);};td_0X.csp_nonce=null;td_0X.td_0T=function(td_b){if(typeof td_b.currentScript!==[][[]]+""&&td_b.currentScript!==null){var td_I=td_b.currentScript.getAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(154,5)):null));
if(typeof td_I!==[][[]]+""&&td_I!==null&&td_I!==""){td_0X.csp_nonce=td_I;}else{if(typeof td_b.currentScript.nonce!==[][[]]+""&&td_b.currentScript.nonce!==null&&td_b.currentScript.nonce!==""){td_0X.csp_nonce=td_b.currentScript.nonce;
}}}};td_0X.td_0m=function(td_F){if(td_0X.csp_nonce!==null){td_F.setAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(154,5)):null),td_0X.csp_nonce);
if(td_F.getAttribute(((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(154,5)):null))!==td_0X.csp_nonce){td_F.nonce=td_0X.csp_nonce;
}}};td_0X.td_3W=function(){try{return new ActiveXObject(activeXMode);}catch(td_d){return null;}};td_0X.td_2M=function(){if(window.XMLHttpRequest){return new XMLHttpRequest();}if(window.ActiveXObject){var td_f=[((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(159,18)):null),((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(177,14)):null),((typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d)!=="undefined"&&typeof(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f)!=="undefined")?(td_0X.tdz_d27185feffe143c087bd4e0fa17d4a7d.td_f(191,17)):null)];
for(var td_Q=0;td_Q<td_f.length;td_Q++){var td_S=td_0X.td_3W(td_f[td_Q]);if(td_S!==null){return td_S;}}}return null;};td_0X.tdz_9e6fc63d34444af781ba8302f8551b64=new td_0X.td_5l("\x39\x65\x36\x66\x63\x36\x33\x64\x33\x34\x34\x34\x34\x61\x66\x37\x38\x31\x62\x61\x38\x33\x30\x32\x66\x38\x35\x35\x31\x62\x36\x34\x34\x64\x30\x31\x34\x34\x33\x39\x31\x30\x35\x35\x34\x31\x30\x64\x34\x33\x34\x30\x36\x37\x37\x37\x36\x36\x32\x38\x33\x36\x36\x33\x35\x31\x35\x35\x31\x36\x30\x34\x34\x30\x34\x37\x31\x66\x35\x38\x30\x37\x34\x65\x35\x34\x34\x36\x35\x32\x31\x30\x35\x66\x34\x34\x34\x64\x30\x39\x35\x39\x30\x37\x30\x37\x35\x33\x35\x37\x30\x37\x35\x63\x35\x39\x34\x34\x35\x38\x35\x31\x31\x35\x30\x33\x34\x34\x34\x61\x35\x32\x30\x62\x30\x63\x35\x66\x37\x61\x37\x64\x37\x35\x30\x37\x35\x34\x34\x31\x35\x30\x35\x63\x31\x32\x34\x32\x34\x64\x35\x31\x30\x63\x35\x32\x30\x32\x30\x36\x35\x38");
function td_1a(td_P){var td_K="";var td_R=function(){var td_G=Math.floor(Math.random()*62);if(td_G<10){return td_G;}if(td_G<36){return String.fromCharCode(td_G+55);}return String.fromCharCode(td_G+61);
};while(td_K.length<td_P){td_K+=td_R();}return((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(0,4)):null)+td_K;
}function td_1U(td_V){var td_l=td_1a(5);if(typeof(td_5i)!==[][[]]+""){td_5i(td_l,td_V);}return td_l;}function td_2e(td_A,td_Z,td_f){var td_L=td_Z.getElementsByTagName(Number(103873).toString(18)).item(0);
var td_S=td_Z.createElement(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(4,6)):null));
var td_b=td_1U(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(10,6)):null));
td_S.setAttribute(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(16,2)):null),td_b);
td_S.setAttribute(Number(1285914).toString(35),((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(18,15)):null));
td_0X.td_0m(td_S);if(typeof td_f!==[][[]]+""){var td_J=false;td_S.onload=td_S.onreadystatechange=function(){if(!td_J&&(!this.readyState||this.readyState===((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(33,6)):null)||this.readyState===((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(39,8)):null))){td_J=true;
td_f();}};td_S.onerror=function(td_l){td_J=true;td_f();};}td_S.setAttribute(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(47,3)):null),td_A);
td_L.appendChild(td_S);}function td_3r(td_z,td_p,td_Q,td_S){var td_t=td_S.createElement(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(50,3)):null));
var td_P=td_1U(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(53,3)):null));
td_t.setAttribute(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(16,2)):null),td_P);
td_t.setAttribute(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(56,3)):null),((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(59,5)):null));
td_t.style.visibility=((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(64,6)):null);
td_t.setAttribute(((typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64)!=="undefined"&&typeof(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f)!=="undefined")?(td_0X.tdz_9e6fc63d34444af781ba8302f8551b64.td_f(47,3)):null),td_p);
if(typeof td_Q!==[][[]]+""){td_t.onload=td_Q;td_t.onabort=td_Q;td_t.onerror=td_Q;td_t.oninvalid=td_Q;}td_z.appendChild(td_t);}function td_5j(td_X,td_V){var td_O=td_V.getElementsByTagName(Number(103873).toString(18))[0];
td_3r(td_O,td_X,null,td_V);}td_0X.tdz_aa782c47547142729de3842910dc149a=new td_0X.td_5l("\x61\x61\x37\x38\x32\x63\x34\x37\x35\x34\x37\x31\x34\x32\x37\x32\x39\x64\x65\x33\x38\x34\x32\x39\x31\x30\x64\x63\x31\x34\x39\x61\x34\x31\x32\x65\x36\x37\x36\x61\x31\x64\x34\x33\x37\x62\x36\x37\x36\x37\x37\x62\x34\x37\x35\x34\x34\x36\x35\x33\x37\x38\x34\x32\x35\x63\x31\x36\x30\x34\x31\x33\x37\x35\x35\x64\x35\x63\x35\x30\x37\x34\x35\x34\x30\x33\x30\x36\x31\x65\x37\x31\x35\x64\x30\x36\x30\x34\x32\x34\x35\x33\x35\x66\x31\x64\x32\x36\x35\x30\x35\x30\x37\x30\x35\x30\x35\x30\x37\x30\x31\x62\x37\x37\x35\x33\x35\x35\x37\x38\x32\x31\x30\x31\x35\x34\x35\x31\x37\x62\x36\x31\x31\x36\x37\x34\x35\x34\x30\x33\x30\x61\x37\x65\x36\x37\x36\x30\x30\x30\x32\x33\x31\x33\x35\x38\x34\x66\x34\x31\x30\x36\x34\x36\x36\x65\x35\x34\x35\x61\x35\x33\x35\x34\x34\x63\x36\x31\x35\x36\x35\x66\x34\x61\x31\x31\x30\x62\x35\x34\x37\x61\x34\x36\x35\x64\x34\x65\x34\x32\x35\x35\x31\x36\x33\x36\x37\x32\x37\x36\x34\x62\x30\x65\x31\x36\x31\x32\x35\x32\x34\x61\x36\x32\x31\x36\x35\x32\x35\x31\x35\x63\x35\x61\x37\x34\x35\x39\x34\x36\x35\x64\x35\x61\x35\x37\x37\x36\x30\x39\x30\x62\x35\x61\x36\x66\x35\x31\x35\x30\x37\x36\x35\x63\x35\x65\x30\x64\x33\x34\x35\x34\x35\x36\x31\x36\x32\x37\x31\x39\x30\x38\x37\x38\x36\x62\x37\x34\x30\x61\x34\x36\x35\x32\x35\x33\x35\x62\x34\x66\x37\x32\x34\x36\x35\x62\x37\x38\x36\x31\x36\x31\x30\x64\x30\x34\x35\x63\x37\x35\x35\x64\x31\x64\x37\x34\x35\x38\x34\x35\x30\x64\x32\x31\x34\x33\x35\x62\x34\x65\x31\x32\x30\x34\x31\x33\x37\x36\x34\x38\x34\x32\x30\x66\x35\x31\x36\x34\x35\x34\x35\x32\x35\x36\x34\x33\x35\x64\x36\x34\x35\x32\x34\x30\x34\x61\x30\x64\x30\x61\x35\x64\x35\x31\x37\x37\x35\x33\x35\x62\x37\x61\x37\x34\x32\x31\x32\x38\x35\x65\x35\x61\x34\x38\x31\x34\x30\x34\x31\x33\x35\x38\x34\x61\x37\x31\x30\x32\x35\x39\x35\x65\x35\x62\x35\x62\x37\x39\x35\x34\x34\x30\x34\x31\x35\x34\x35\x33\x34\x39\x30\x31\x32\x38\x36\x30\x37\x31\x37\x31\x37\x37\x34\x31\x34\x31\x35\x63\x30\x62\x31\x31\x35\x34\x34\x36\x37\x30\x32\x34\x32\x63\x30\x65\x35\x35\x35\x31\x35\x65\x30\x36\x36\x30\x34\x35\x35\x63\x35\x30\x35\x32\x35\x66\x34\x30\x34\x30\x34\x31\x37\x35\x35\x63\x30\x37\x30\x65\x35\x63\x37\x35\x35\x62\x34\x38\x35\x30\x35\x64\x35\x63\x30\x35\x33\x34\x35\x38\x35\x61\x36\x65\x30\x38\x30\x66\x30\x35\x35\x38\x34\x66\x34\x31\x32\x65\x35\x35\x35\x34\x36\x32\x35\x64\x35\x39\x35\x35\x35\x62\x34\x35\x34\x34\x31\x32\x36\x39\x30\x63\x30\x61\x35\x64\x35\x64\x37\x35\x35\x63\x35\x64\x34\x33\x35\x66\x30\x64\x30\x37\x37\x65\x34\x34\x35\x63\x30\x66\x32\x33\x33\x32\x37\x33\x36\x62\x34\x37\x30\x64\x37\x62\x36\x34\x37\x39\x35\x64\x35\x39\x34\x34\x34\x63\x31\x32\x35\x36\x34\x30\x35\x34\x32\x38\x30\x63\x35\x64\x34\x64\x34\x63\x37\x30\x35\x35\x35\x30\x35\x33\x30\x66\x32\x31\x35\x34\x34\x36\x34\x62\x31\x38\x30\x38\x33\x31\x35\x66\x35\x37\x35\x63\x30\x36\x35\x64\x36\x37\x35\x64\x35\x62\x35\x39\x35\x34\x31\x62\x35\x62\x36\x37\x35\x64\x35\x64\x30\x64\x33\x35\x35\x32\x35\x63\x37\x38\x35\x62\x35\x37\x34\x34\x34\x38\x34\x34\x30\x32\x35\x30\x34\x36\x35\x61\x30\x39\x33\x36\x30\x38\x35\x39\x35\x63\x35\x64\x31\x34\x34\x37\x31\x37\x30\x34\x30\x34\x36\x30\x35\x38\x35\x61\x35\x36\x35\x38\x34\x35\x34\x61\x34\x34\x35\x64\x31\x64\x30\x39\x36\x33\x35\x62\x35\x37\x35\x35\x35\x66\x31\x33\x31\x30\x31\x31\x30\x63\x36\x65\x30\x38\x30\x66\x30\x35\x35\x38\x34\x66\x34\x31\x34\x33\x30\x33\x36\x30\x35\x63\x35\x61\x35\x33\x35\x65\x34\x33\x34\x31\x31\x37\x36\x34\x35\x30\x31\x37\x31\x31\x35\x32\x36\x66\x35\x64\x35\x63\x35\x64\x35\x65\x34\x37\x31\x37\x34\x33\x36\x32\x35\x31\x34\x62\x31\x37\x30\x34\x31\x33\x31\x37\x30\x61\x30\x32\x35\x33\x30\x37\x36\x30\x35\x63\x35\x61\x35\x33\x35\x65\x34\x33\x34\x31\x31\x37\x36\x61\x36\x39\x33\x33\x30\x63\x35\x64\x35\x63\x35\x62\x34\x35\x34\x61\x31\x31\x30\x32\x35\x34\x35\x33\x30\x31\x36\x33\x35\x30\x30\x66\x30\x35\x30\x65\x34\x30\x34\x62\x31\x32\x32\x65\x37\x31\x36\x30\x35\x63\x35\x61\x35\x33\x35\x65\x34\x33\x34\x31\x31\x37\x30\x62\x30\x31\x33\x33\x30\x63\x35\x64\x35\x63\x35\x62\x34\x35\x34\x61\x31\x31\x30\x39\x35\x31\x33\x34\x35\x38\x35\x61\x35\x64\x30\x65\x31\x36\x31\x32\x31\x37\x37\x36\x36\x36\x34\x33\x30\x30\x31\x39\x30\x35\x36\x33\x35\x65\x35\x66\x35\x30\x35\x64\x34\x30\x34\x31\x31\x39\x32\x37\x32\x30\x36\x34\x35\x31\x35\x61\x35\x36\x35\x36\x34\x36\x34\x33\x34\x34\x35\x30\x31\x66\x30\x35\x30\x38\x32\x63\x30\x30\x30\x32\x31\x37\x37\x37\x36\x31\x34\x33\x36\x63\x37\x61\x35\x34\x35\x37\x31\x37\x37\x65\x36\x37\x36\x35\x35\x65\x35\x63\x35\x64\x30\x62\x31\x32\x34\x30\x31\x38\x36\x34\x35\x61\x35\x36\x35\x66\x35\x35\x34\x34\x35\x35\x31\x66\x30\x34\x36\x65\x30\x38\x30\x66\x30\x35\x35\x38\x34\x66\x34\x31\x34\x33\x36\x34\x35\x66\x35\x61\x35\x61\x35\x32\x31\x31\x30\x33\x31\x63\x30\x37\x36\x35\x35\x30\x30\x61\x30\x31\x35\x63\x34\x66\x34\x37\x31\x32\x36\x39\x35\x39\x35\x66\x30\x61\x30\x36\x31\x31\x30\x63\x31\x37\x35\x31\x33\x36\x30\x38\x35\x39\x35\x63\x35\x64\x31\x34\x34\x37\x31\x37\x36\x35\x35\x63\x35\x38\x35\x66\x35\x31\x31\x32\x30\x66\x31\x63\x30\x38\x33\x33\x30\x63\x35\x64\x35\x63\x35\x62\x34\x35\x34\x61\x31\x31\x36\x30\x30\x63\x30\x63\x35\x66\x35\x31\x31\x39\x35\x30\x35\x31\x34\x66\x30\x37\x34\x64\x35\x63\x30\x38\x35\x61\x35\x38\x34\x32\x35\x61\x36\x30\x35\x38\x35\x61\x35\x36\x35\x38\x34\x35\x34\x61\x34\x34\x35\x34\x30\x32\x37\x35\x35\x35\x35\x31\x37\x30\x35\x66\x34\x34\x30\x31\x30\x66\x35\x38\x36\x34\x35\x38\x30\x35\x34\x31\x33\x39\x31\x37\x35\x31\x37\x64\x33\x30\x31\x34\x37\x38\x36\x35\x36\x36\x35\x65\x34\x32\x31\x34\x35\x63\x35\x38\x34\x36\x31\x39\x30\x35\x34\x35\x34\x35\x35\x39\x35\x38\x35\x62\x35\x64\x31\x31\x36\x35\x33\x36\x32\x66\x36\x61\x35\x62\x35\x62\x30\x62\x30\x34\x30\x32\x34\x33\x31\x38\x36\x31\x30\x32\x35\x32\x35\x36\x34\x37\x35\x64\x36\x35\x35\x34\x35\x39\x35\x64\x34\x33\x35\x37\x37\x37\x30\x62\x31\x31\x35\x61\x35\x65\x35\x64\x35\x31\x35\x38\x34\x35\x35\x39\x30\x62\x30\x64\x36\x63\x34\x37\x35\x38\x30\x37\x30\x30\x31\x33\x35\x65\x35\x61\x34\x30\x30\x32\x34\x32\x35\x32\x30\x66\x31\x62\x31\x38\x37\x33\x34\x36\x35\x33\x34\x31\x35\x37\x35\x63\x30\x30\x30\x32\x35\x36\x30\x32\x31\x62\x31\x64\x34\x39\x34\x34\x35\x36\x30\x32\x30\x61\x35\x66\x30\x65\x31\x36\x34\x65\x30\x38\x33\x31\x35\x66\x35\x37\x35\x63\x30\x36\x31\x62\x35\x65\x36\x35\x35\x35\x35\x33\x34\x32\x34\x30\x34\x30\x35\x65\x35\x63\x35\x65\x30\x64\x33\x35\x35\x32\x35\x63\x31\x34\x36\x61\x34\x39\x35\x64\x35\x31\x31\x30\x30\x35\x35\x65\x34\x36\x35\x34\x33\x37\x30\x34\x31\x33\x34\x34\x35\x31\x35\x64\x30\x64\x30\x35\x30\x66\x34\x35\x34\x63\x31\x37\x36\x32\x35\x31\x35\x35\x35\x38\x35\x37\x31\x39\x32\x32\x30\x39\x34\x36\x35\x64\x35\x61\x34\x36\x31\x39\x37\x38\x35\x33\x30\x62\x30\x64\x34\x32");
var td_0X=td_0X||{};var td_s=0;var td_v=1;var td_C=2;var td_y=3;var td_g=4;td_0X.td_0B=td_s;var td_5x={td_0f:function(){if(typeof navigator!==[][[]]+""){this.td_o(navigator.userAgent,navigator.vendor,navigator.platform,navigator.appVersion,window.opera);
}},td_o:function(td_d,td_l,td_L,td_P,td_K){this.td_N=[{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(0,5)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(5,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(9,5)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(14,10)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(14,10)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(14,10)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(24,5)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(33,4)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(37,3)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(40,5)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(45,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(49,7)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(56,6)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(62,9)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(62,9)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(71,6)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(77,14)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(77,14)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(91,9)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(91,9)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(100,6)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(100,6)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(106,6)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(106,6)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(112,7)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(119,8)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(112,7)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(127,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(132,7)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(127,5)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(139,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(106,6)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(139,5)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(144,18)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(144,18)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(144,18)):null)},{string:td_l,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(162,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(173,7)):null)},{prop:td_K,identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(9,5)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(173,7)):null)},{string:td_l,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(180,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(180,4)):null)},{string:td_l,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(184,3)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(187,9)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(132,7)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(132,7)):null)},{string:td_l,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(196,6)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(196,6)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(202,8)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(202,8)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(210,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(214,8)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(210,4)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(222,8)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(222,8)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(222,8)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(230,7)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(214,8)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(237,2)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(239,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(244,7)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(237,2)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(244,7)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(202,8)):null),versionSearch:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(244,7)):null)}];
this.td_e=[{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(251,3)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(254,7)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(261,3)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(261,3)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(264,13)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(264,13)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(277,7)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(277,7)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(284,7)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(284,7)):null)},{string:td_d,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(291,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(291,5)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(296,9)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(277,7)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(305,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(305,5)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(310,10)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(310,10)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(320,6)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(326,11)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(337,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(337,4)):null)}];
this.td_H=[{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(251,3)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(254,7)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(261,3)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(261,3)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(296,9)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(277,7)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(341,11)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(277,7)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(305,5)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(305,5)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(310,10)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(310,10)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(320,6)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(320,6)):null)},{string:td_L,subString:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(337,4)):null),identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(337,4)):null)}];
this.td_M=[{identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(254,7)):null),versionMap:[{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(352,10)):null),r:/(Windows 10.0|Windows NT 10.0)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(362,11)):null),r:/(Windows 8.1|Windows NT 6.3)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(373,9)):null),r:/(Windows 8|Windows NT 6.2)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(382,9)):null),r:/(Windows 7|Windows NT 6.1)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(391,13)):null),r:/Windows NT 6.0/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(404,19)):null),r:/Windows NT 5.2/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(423,10)):null),r:/(Windows NT 5.1|Windows XP)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(433,12)):null),r:/(Windows NT 5.0|Windows 2000)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(445,10)):null),r:/(Win 9x 4.90|Windows ME)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(455,10)):null),r:/(Windows 98|Win98)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(465,10)):null),r:/(Windows 95|Win95|Windows_95)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(475,14)):null),r:/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(489,10)):null),r:/Windows CE/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(499,12)):null),r:/Win16/}]},{identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(261,3)):null),versionMap:[{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(511,8)):null),r:/Mac OS X/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(519,6)):null),r:/(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/}]},{identity:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(264,13)):null),versionMap:[{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(525,17)):null),r:/Windows Phone 6.0/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(542,17)):null),r:/Windows Phone 7.0/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(559,17)):null),r:/Windows Phone 8.0/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(576,17)):null),r:/Windows Phone 8.1/},{s:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(593,18)):null),r:/Windows Phone 10.0/}]}];
this.td_1j=(typeof window.orientation!==[][[]]+"");this.td_4B=this.td_h(this.td_H)||((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
this.td_1Z=this.td_D(this.td_1j,this.td_4B)||((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
this.td_5b=this.td_h(this.td_N)||((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
this.td_2X=this.td_x(this.td_5b,td_d)||this.td_x(this.td_5b,td_P)||((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
this.td_4V=this.td_h(this.td_e)||((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
this.td_4y=this.td_k(this.td_M,this.td_4V,td_d,td_P)||this.td_4V;this.td_Y();},td_k:function(td_m,td_z,td_c,td_J){var td_l=td_c;var td_Z=td_J;var td_F=td_z;var td_T;for(var td_O=0;td_O<td_m.length;td_O++){if(td_m[td_O].identity===td_z){for(var td_E=0;
td_E<td_m[td_O].versionMap.length;td_E++){var td_S=td_m[td_O].versionMap[td_E];if(td_S.r.test(td_l)){td_F=td_S.s;if(/Windows/.test(td_F)){if(td_F===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(352,10)):null)){if(td_5x.td_r()){td_F=((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(618,10)):null);
}td_0X.td_0B=td_v;td_5x.td_B();}return td_F;}break;}}break;}}switch(td_F){case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(511,8)):null):td_F=null;
var td_R=/(Mac OS X 10[\.\_\d]+)/.exec(td_l);if(td_R!==null&&td_R.length>=1){td_F=td_R[1];}if(typeof navigator.platform!==[][[]]+""&&navigator.platform!==null&&navigator.platform===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(628,8)):null)&&typeof navigator.maxTouchPoints!==[][[]]+""&&navigator.maxTouchPoints!==null&&navigator.maxTouchPoints===5){if(typeof"".split!==[][[]]+""&&"".split!==null){var td_I=td_F.split(" ");
if(td_I.length===4){var td_n=/(Version\/[\.\d]+)/.exec(td_l);if(td_n!==null&&td_n.length>1){var td_t=td_n[1];if(td_t!==null&&td_t.length>1){var td_a=td_t.split("/");if(td_a!==null&&td_a.length>1){td_F=((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(636,7)):null)+td_a[1];
}}}}}}break;case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(277,7)):null):td_F=null;
var td_Q=/[^-](Android[^\d]?[\.\_\d]+)/.exec(td_l);if(td_Q!==null&&td_Q.length>=1){td_F=td_Q[1];}break;case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(337,4)):null):case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(320,6)):null):case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(326,11)):null):td_F=null;
td_T=/OS (\d+)_(\d+)_?(\d+)?/.exec(td_Z);if(td_T!==null){var td_q=td_T.length>=1?td_T[1]:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
var td_A=td_T.length>=2?td_T[2]:((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(611,7)):null);
var td_p=td_T.length>=3?td_T[3]|"0":"0";td_F=((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(643,4)):null)+td_q+"."+td_A+"."+td_p;
}break;default:return null;}return td_F;},td_h:function(td_R){for(var td_l=0;td_l<td_R.length;++td_l){var td_T=td_R[td_l].string;var td_E=td_R[td_l].prop;this.versionSearchString=td_R[td_l].versionSearch||td_R[td_l].identity;
if(td_T){if(td_T.indexOf(td_R[td_l].subString)!==-1){return td_R[td_l].identity;}}else{if(td_E){return td_R[td_l].identity;}}}},td_x:function(td_T,td_K){if(!td_T){return null;}var td_O;switch(td_T){case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null):var td_Z=/\WVersion[^\d]([\.\d]+)/.exec(td_K);
if(td_Z!==null&&td_Z.length>=1){td_O=td_Z[1];}break;case ((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(9,5)):null):if(this.versionSearchString===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(647,3)):null)){var td_Q=/\WOPR[^\d]*([\.\d]+)/.exec(td_K);
if(td_Q!==null&&td_Q.length>=1){td_O=td_Q[1];}break;}default:var td_R=td_K.indexOf(this.versionSearchString);if(td_R!==-1){td_O=td_K.substring(td_R+this.versionSearchString.length+1);}break;}if(td_O){return parseFloat(td_O);
}return null;},td_W:function(td_J){var td_a=null;try{td_a=new Worker(td_J);}catch(td_Z){if(td_a!==null&&typeof td_a.terminate!==[][[]]+""){td_a.terminate();}return(td_Z.toString().indexOf(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(650,18)):null))!==-1);
}return false;},td_D:function(isMobile,osNoUA){var psc=this.td_W;try{var check=((typeof window.opr!==[][[]]+"")&&(typeof td_w.addons!==[][[]]+""))||(typeof window.opera!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(9,5)):null);
}check=(typeof InstallTrigger!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(132,7)):null);
}check=/constructor/i.test(window.HTMLElement)||(function(p){return p.toString()===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(668,33)):null);
})(!window[((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(701,6)):null)]||(typeof safari!==[][[]]+""&&safari.pushNotification));
if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null);
}check=(typeof window.safari!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null);
}check=
/*@cc_on!@*/
false||(typeof document.documentMode!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(214,8)):null);
}if(!check&&(typeof window.StyleMedia!==[][[]]+"")){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null);
}if(psc(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(707,8)):null))){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(715,5)):null);
}if(psc(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(720,7)):null))){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(29,4)):null);
}if(psc(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(727,9)):null))){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(100,6)):null);
}check=(typeof window.chrome!==[][[]]+"")&&(typeof window.yandex==[][[]]+"")&&((typeof window.chrome.webstore!==[][[]]+"")||(typeof window.chrome.runtime!==[][[]]+"")||(typeof window.chrome.loadTimes!==[][[]]+""));
if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(106,6)):null);
}if(isMobile){check=(typeof window.chrome!==[][[]]+"")&&(typeof window.chrome.Benchmarking!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(77,14)):null);
}check=(typeof window.ucapi!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(91,9)):null);
}}if(osNoUA===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(320,6)):null)||osNoUA===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(337,4)):null)){if(typeof navigator.serviceWorker!==[][[]]+""){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null);
}if(typeof window.$jscomp!==[][[]]+""){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(106,6)):null);
}}check=(typeof window.chrome!==[][[]]+"")&&(typeof window.yandex!==[][[]]+"");if(check){return((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(71,6)):null);
}}catch(err){}return null;},td_Y:function(){if(this.td_1j!==true||this.td_4B!==((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(261,3)):null)){return;
}this.td_4B=((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(736,11)):null);
this.td_4V=this.td_4B;var td_l=(typeof this.td_4y===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(747,6)):null)&&this.td_4y!==null&&this.td_4y.indexOf(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(753,6)):null))!==-1);
if(td_l){return;}this.td_4y=this.td_4V;},td_u:function(td_J){return(typeof td_J!==[][[]]+""&&td_J!==null);},td_j:function(td_a){this.td_4y=td_a;},td_B:function(){if(this.td_5b===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(132,7)):null)||this.td_5b===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null)){td_0X.td_0B=td_g;
return;}if(td_0X.td_0B>td_v){return;}td_0X.td_0B=td_C;if(td_5x.td_u(navigator.userAgentData)&&td_5x.td_u(navigator.userAgentData.getHighEntropyValues)){var td_Q=navigator.userAgentData.getHighEntropyValues([((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(759,15)):null)]);
if(td_5x.td_u(td_Q)&&td_5x.td_u(td_Q.then)){td_Q.then(function(td_m){function td_L(td_U){return(typeof td_U!==[][[]]+""&&td_U!==null);}if(td_L(navigator.userAgentData.platform)&&navigator.userAgentData.platform===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(254,7)):null)){if(td_L(td_m)&&td_L(td_m.platformVersion)&&td_L(td_m.platformVersion.split)){var td_f=parseInt(td_m.platformVersion.split(".")[0]);
if(td_f>=13){td_5x.td_j(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(618,10)):null));
td_0X.td_0B=td_y;}else{if(td_f>0){td_5x.td_j(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(352,10)):null));
}td_0X.td_0B=td_g;}}}});}}},td_r:function(){if(this.td_5b===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(132,7)):null)||this.td_5b===((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(167,6)):null)){return false;
}try{if(td_5x.td_u(document.fonts)&&td_5x.td_u(document.fonts.check)){return document.fonts.check(((typeof(td_0X.tdz_aa782c47547142729de3842910dc149a)!=="undefined"&&typeof(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f)!=="undefined")?(td_0X.tdz_aa782c47547142729de3842910dc149a.td_f(774,23)):null));
}}catch(td_A){}return false;},td_N:{},td_e:{},td_H:{},td_M:{}};var td_5Z={};td_5Z.td_2d=function(td_V,td_G){td_G=(typeof td_G===[][[]]+"")?true:td_G;if(td_G){td_V=td_1D.td_4a(td_V);}var td_p=[1518500249,1859775393,2400959708,3395469782];td_V+=String.fromCharCode(128);
var td_O=td_V.length/4+2;var td_J=Math.ceil(td_O/16);var td_I=new Array(td_J);for(var td_Q=0;td_Q<td_J;td_Q++){td_I[td_Q]=new Array(16);for(var td_a=0;td_a<16;td_a++){td_I[td_Q][td_a]=(td_V.charCodeAt(td_Q*64+td_a*4)<<24)|(td_V.charCodeAt(td_Q*64+td_a*4+1)<<16)|(td_V.charCodeAt(td_Q*64+td_a*4+2)<<8)|(td_V.charCodeAt(td_Q*64+td_a*4+3));
}}td_I[td_J-1][14]=((td_V.length-1)*8)/Math.pow(2,32);td_I[td_J-1][14]=Math.floor(td_I[td_J-1][14]);td_I[td_J-1][15]=((td_V.length-1)*8)&4294967295;var td_T=1732584193;var td_f=4023233417;var td_m=2562383102;
var td_z=271733878;var td_A=3285377520;var td_n=new Array(80);var td_E,td_R,td_Z,td_F,td_U;for(var td_Q=0;td_Q<td_J;td_Q++){for(var td_l=0;td_l<16;td_l++){td_n[td_l]=td_I[td_Q][td_l];}for(var td_l=16;td_l<80;
td_l++){td_n[td_l]=td_5Z.td_5q(td_n[td_l-3]^td_n[td_l-8]^td_n[td_l-14]^td_n[td_l-16],1);}td_E=td_T;td_R=td_f;td_Z=td_m;td_F=td_z;td_U=td_A;for(var td_l=0;td_l<80;td_l++){var td_S=Math.floor(td_l/20);var td_L=(td_5Z.td_5q(td_E,5)+td_5Z.f(td_S,td_R,td_Z,td_F)+td_U+td_p[td_S]+td_n[td_l])&4294967295;
td_U=td_F;td_F=td_Z;td_Z=td_5Z.td_5q(td_R,30);td_R=td_E;td_E=td_L;}td_T=(td_T+td_E)&4294967295;td_f=(td_f+td_R)&4294967295;td_m=(td_m+td_Z)&4294967295;td_z=(td_z+td_F)&4294967295;td_A=(td_A+td_U)&4294967295;
}return td_5Z.td_2v(td_T)+td_5Z.td_2v(td_f)+td_5Z.td_2v(td_m)+td_5Z.td_2v(td_z)+td_5Z.td_2v(td_A);};td_5Z.f=function(td_F,td_d,td_a,td_p){switch(td_F){case 0:return(td_d&td_a)^(~td_d&td_p);case 1:return td_d^td_a^td_p;
case 2:return(td_d&td_a)^(td_d&td_p)^(td_a&td_p);case 3:return td_d^td_a^td_p;}};td_5Z.td_5q=function(td_F,td_i){return(td_F<<td_i)|(td_F>>>(32-td_i));};td_5Z.td_2v=function(td_S){var td_c="",td_l;for(var td_V=7;
td_V>=0;td_V--){td_l=(td_S>>>(td_V*4))&15;td_c+=td_l.toString(16);}return td_c;};var td_1D={};td_1D.td_4a=function(td_X){var td_L=td_X.replace(/[\u0080-\u07ff]/g,function(td_A){var td_R=td_A.charCodeAt(0);
return String.fromCharCode(192|td_R>>6,128|td_R&63);});td_L=td_L.replace(/[\u0800-\uffff]/g,function(td_A){var td_U=td_A.charCodeAt(0);return String.fromCharCode(224|td_U>>12,128|td_U>>6&63,128|td_U&63);
});return td_L;};function td_1q(td_J){return td_5Z.td_2d(td_J,true);}var td_0X=td_0X||{};td_0X.td_4Q=function(){};td_0X.hasDebug=false;td_0X.trace=function(){};td_0X.hasTrace=false;td_0k();</script></body></html>
z
End
